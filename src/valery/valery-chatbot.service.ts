/**
 * Servicio especializado para manejar chatbots de tipo Valery.
 * Gestiona sesiones persistentes, autenticaci√≥n autom√°tica, b√∫squedas inteligentes
 * y an√°lisis de patrones de usuario para una experiencia personalizada.
 * 
 * @class ValeryChatbotService
 */
import { Injectable, Logger, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import { ValeryDbService } from './valery-db.service';
import { TemplateService, TemplateContext } from '../chat/services/template.service';
import { AutoResponseService } from '../chat/services/auto-response.service';
import { ChatService } from '../chat/chat.service';
import { TemplateType } from '../chat/entities/message-template.entity';
import { PersistentSession } from '../chat/entities/persistent-session.entity';
import { SearchHistory } from '../chat/entities/search-history.entity';
import { ShoppingCart } from '../chat/entities/shopping-cart.entity';
import { ChatMessage } from '../chat/entities/message.entity';
import { ValeryToolsService } from './tools/valery-tools.service';
import { Client } from 'pg';

interface EstadoChat {
  paso: number;
  cliente?: any;
  productos: any[];
  metodoPago?: any;
  banco?: any;
  total: number;
  subtotal: number;
  iva: number;
  tipoEntrega?: string;
  direccionEntrega?: string;
  cedulaRifIngresada?: string;
  nombreCompletoIngresado?: string;
  carritoCompras: any[];
  idPedidoCreado?: string;
  comprobanteInfo?: string;
  ocrMontoReportado?: string;
  ocrReferenciaReportada?: string;
  modoDebug?: boolean;
}

@Injectable()
export class ValeryChatbotService {
  private readonly logger = new Logger(ValeryChatbotService.name);
  private estadosChat: Map<string, EstadoChat> = new Map();
  private readonly SESSION_TIMEOUT = 2 * 60 * 60 * 1000; // 2 horas para sesiones persistentes

  constructor(
    private readonly configService: ConfigService,
    private valeryDbService: ValeryDbService,
    @Inject(forwardRef(() => TemplateService))
    private templateService: TemplateService,
    @Inject(forwardRef(() => AutoResponseService))
    private autoResponseService: AutoResponseService,
    @Inject(forwardRef(() => ChatService))
    private chatService: ChatService,
    private readonly valeryToolsService: ValeryToolsService
  ) {
    this.logger.log('üöÄ ValeryChatbotService inicializado con funcionalidades avanzadas (similar a n8n)');
    // Limpiar sesiones inactivas cada 30 minutos
    setInterval(() => this.cleanInactiveSessions(), 30 * 60 * 1000);
  }

  async handleMessage(message: string, phoneNumber: string, chatbotId: string): Promise<string> {
    try {
      this.logger.debug(`üì± Procesando mensaje de ${phoneNumber}: ${message}`);
      
      // Normalizar n√∫mero de tel√©fono
      const normalizedPhoneNumber = this.normalizePhoneNumber(phoneNumber);
      
      // Obtener o crear sesi√≥n persistente
      let session = await this.getOrCreateSession(normalizedPhoneNumber, chatbotId);
      
      // Si es una nueva sesi√≥n (messageCount === 0), buscar cliente autom√°ticamente
      if (session.messageCount === 0) {
        this.logger.log(`üÜï PRIMERA INTERACCI√ìN - Ejecutando autovalidaci√≥n por tel√©fono: ${normalizedPhoneNumber}`);
        await this.autoAuthenticateByPhone(session, chatbotId);
        
        // üÜï ANALIZAR SI EL PRIMER MENSAJE CONTIENE C√âDULA
        const messageIntent = await this.analyzeMessageIntent(message, session);
        this.logger.log(`üîç An√°lisis del primer mensaje: ${messageIntent.type} (${message})`);
        
        if (messageIntent.type === 'identification') {
          this.logger.log(`üÜî C√âDULA DETECTADA EN PRIMER MENSAJE: ${messageIntent.entities.identification}`);
          
          // Procesar la c√©dula inmediatamente
          session.messageCount += 1;
          session.lastActivity = new Date();
          session.lastUserMessage = message;
          
          const response = await this.handleClientIdentification(messageIntent.entities.identification, session, chatbotId);
          session.lastBotResponse = response;
          await this.chatService.saveSession(session);
          await this.saveMessage(session, message, response);
          return response;
        }
        
        // Si no es c√©dula, generar mensaje de bienvenida normal
        this.logger.log(`üí¨ Generando mensaje de bienvenida para primer mensaje: ${message}`);
        
        // Incrementar messageCount ANTES de generar el mensaje de bienvenida
        session.messageCount += 1;
        session.lastActivity = new Date();
        session.lastUserMessage = message;
        
        await this.chatService.saveSession(session);
        
        // Generar saludo personalizado e inteligente
        const welcomeMessage = await this.generateIntelligentWelcome(session, chatbotId);
        session.lastBotResponse = welcomeMessage;
        await this.chatService.saveSession(session);
        await this.saveMessage(session, message, welcomeMessage);
        return welcomeMessage;
      }
      
      this.logger.log(`üîÑ SESI√ìN EXISTENTE - messageCount: ${session.messageCount}, contexto: ${session.context}, autenticado: ${session.isAuthenticated}`);
      
      // Actualizar actividad de la sesi√≥n para mensajes subsiguientes
      session.lastActivity = new Date();
      session.lastUserMessage = message;
      session.messageCount += 1;
      
      // Analizar y procesar el mensaje con IA
      const response = await this.processIntelligentMessage(message, session, chatbotId);
      
      // Guardar el intercambio de mensajes
      session.lastBotResponse = response;
      await this.chatService.saveSession(session);
      await this.saveMessage(session, message, response);
      
      return response;
      
    } catch (error) {
      this.logger.error(`‚ùå Error cr√≠tico al procesar mensaje: ${error.message}`, error.stack);
      
      // Respuesta de error inteligente
      const errorMessage = await this.handleIntelligentError(error, chatbotId);
      return errorMessage;
    }
  }

  private async getOrCreateSession(phoneNumber: string, chatbotId: string): Promise<PersistentSession> {
    try {
      // Primero intentamos encontrar una sesi√≥n existente
      let session = await this.chatService.findSession(phoneNumber, 'active');

      if (session) {
        // Verificar si la sesi√≥n ha expirado
        const timeSinceLastActivity = Date.now() - session.lastActivity.getTime();
        if (timeSinceLastActivity > this.SESSION_TIMEOUT) {
          // Reactivar sesi√≥n expirada
          session.status = 'active';
          session.lastActivity = new Date();
          this.logger.debug(`üîÑ Sesi√≥n reactivada: ${session.id}`);
        }
        
        // Actualizar el √∫ltimo momento de actividad
        session.lastActivity = new Date();
        await this.chatService.saveSession(session);
        
        return session;
      } else {
        try {
          // Crear una nueva sesi√≥n
          session = this.chatService.createSession(phoneNumber, chatbotId, 'active');
          await this.chatService.saveSession(session);
          this.logger.debug(`üÜï Nueva sesi√≥n persistente creada: ${session.id}`);
          return session;
        } catch (createError) {
          // Si falla por UNIQUE constraint, intentamos recuperar la sesi√≥n existente una vez m√°s
          if (createError.message.includes('UNIQUE constraint failed') || 
              createError.message.includes('duplicate key value')) {
            this.logger.warn(`Conflicto al crear sesi√≥n para ${phoneNumber}, intentando recuperar existente...`);
            
            // Intentar recuperar nuevamente (puede haber sido creada en paralelo)
            session = await this.chatService.findSession(phoneNumber, 'active');
            if (session) {
              session.lastActivity = new Date();
              await this.chatService.saveSession(session);
              return session;
            }
            
            // Si a√∫n no la encontramos, buscamos por n√∫mero sin importar el estado
            const anySession = await this.chatService.findSessionByPhoneOnly(phoneNumber);
            if (anySession) {
              // Reactivar la sesi√≥n encontrada
              anySession.status = 'active';
              anySession.lastActivity = new Date();
              await this.chatService.saveSession(anySession);
              this.logger.debug(`‚ôªÔ∏è Sesi√≥n existente reactivada: ${anySession.id}`);
              return anySession;
            }
          }
          // Si llegamos aqu√≠, es un error que no podemos manejar
          throw createError;
        }
      }
    } catch (error) {
      this.logger.error(`Error al obtener/crear sesi√≥n: ${error.message}`, error.stack);
      throw error;
    }
  }

  private normalizePhoneNumber(phoneNumber: string): string {
    this.logger.debug(`üîß Normalizando n√∫mero: "${phoneNumber}"`);
    
    // Limpiar y normalizar n√∫mero de tel√©fono
    const cleanNumber = phoneNumber.replace(/@s\.whatsapp\.net|[\s\-\(\)]/g, '');
    this.logger.debug(`üîß N√∫mero limpio: "${cleanNumber}"`);
    
    // Convertir formato internacional a local venezolano
    if (cleanNumber.startsWith('58') && cleanNumber.length > 10) {
      const normalized = '0' + cleanNumber.slice(2);
      this.logger.debug(`üîß N√∫mero normalizado (58->0): "${normalized}"`);
      return normalized;
    }
    
    this.logger.debug(`üîß N√∫mero sin cambios: "${cleanNumber}"`);
    return cleanNumber;
  }

  private async autoAuthenticateByPhone(session: PersistentSession, chatbotId: string): Promise<void> {
    try {
      this.logger.log('üîç AUTOVALIDACION POR TELEFONO: ' + session.phoneNumber);
      
      // USAR CONFIGURACION DIRECTA DEL CHATBOT
      const chatbotConfig = await this.getChatbotConfig(chatbotId);
      
      if (!chatbotConfig?.externalDbConfig) {
        this.logger.warn('‚ùå No hay configuraci√≥n de BD externa en el chatbot');
        session.isNewClient = true;
        session.isAuthenticated = false;
        session.context = 'new_client';
        return;
      }
      
      const dbConfig = chatbotConfig.externalDbConfig;
      this.logger.log('üîó Usando BD externa: ' + dbConfig.host + ':' + dbConfig.port + '/' + dbConfig.database);
      
      // CREAR CONEXION DIRECTA
      const { Client } = require('pg');
      const dbClient = new Client({
        host: dbConfig.host,
        port: dbConfig.port,
        database: dbConfig.database,
        user: dbConfig.username,
        password: dbConfig.password,
        ssl: dbConfig.ssl || false
      });
      
      await dbClient.connect();
      this.logger.log('‚úÖ Conexi√≥n directa establecida');
      
      // BUSCAR CLIENTE POR TELEFONO CON MULTIPLES FORMATOS
      const phoneFormats = [
        session.phoneNumber,                          // Original: 584245325586
        session.phoneNumber.replace(/^58/, ''),       // Sin c√≥digo pa√≠s: 4245325586  
        session.phoneNumber.replace(/^584/, '04'),    // Formato nacional: 04245325586
        session.phoneNumber.replace(/^58/, '0'),      // Con 0 inicial: 04245325586
        '+' + session.phoneNumber,                    // Internacional: +584245325586
        session.phoneNumber.slice(-10),               // √öltimos 10: 4245325586
        session.phoneNumber.slice(-11),               // √öltimos 11: 24245325586
        '0' + session.phoneNumber.slice(-10),         // 0 + √∫ltimos 10: 04245325586
        session.phoneNumber.replace(/^584(.*)/, '0414$1'), // Cambiar operadora 424‚Üí414
        session.phoneNumber.replace(/^584(.*)/, '0416$1'), // Cambiar operadora 424‚Üí416
        session.phoneNumber.replace(/^584(.*)/, '0426$1')  // Cambiar operadora 424‚Üí426
      ];
      
      this.logger.log('üîç Buscando telefono en formatos: ' + phoneFormats.join(', '));
      
      const query = `
        SELECT 
          idcliente,
          codigocliente,
          nombre,
          rif,
          direccion1,
          direccion2,
          telefono1,
          telefono2,
          email,
          tienecredito,
          diascredito,
          saldo,
          status,
          fechacreacion,
          fechaultimaventa,
          pagos
        FROM clientes 
        WHERE (telefono1 = ANY($1) OR telefono2 = ANY($1))
          AND status IS NOT NULL
          AND status != 'INACTIVO'
        ORDER BY 
          CASE 
            WHEN telefono1 = ANY($1) THEN 1
            WHEN telefono2 = ANY($1) THEN 2
            ELSE 3
          END,
          fechaultimaventa DESC NULLS LAST,
          idcliente DESC
        LIMIT 1
      `
      
      const result = await dbClient.query(query, [phoneFormats]);
      await dbClient.end();
      
      if (result.rows && result.rows.length > 0) {
        const cliente = result.rows[0];
        
        this.logger.log('üéâ CLIENTE ENCONTRADO! ' + cliente.nombre + ' (' + cliente.codigocliente + ')');
        this.logger.log('üì± Telefonos BD: ' + cliente.telefono1 + ' | ' + cliente.telefono2);
        
        // Cliente encontrado - autenticar automaticamente
        session.clientId = cliente.codigocliente;
        session.clientName = cliente.nombre;
        session.identificationNumber = cliente.rif;
        session.isAuthenticated = true;
        session.isNewClient = false;
        session.context = 'menu';
        session.metadata = {
          ...session.metadata,
          clientInfo: {
            hasCredit: !!cliente.tienecredito,
            creditDays: cliente.diascredito,
            balance: cliente.saldo,
            status: cliente.status,
            address: cliente.direccion1,
            email: cliente.email
          }
        };
        
        this.logger.log('‚úÖ Cliente autenticado automaticamente: ' + cliente.nombre);
        
      } else {
        this.logger.log('‚ùå CLIENTE NO ENCONTRADO para telefono: ' + session.phoneNumber);
        this.logger.log('üîç Formatos buscados: ' + phoneFormats.join(', '));
        
        // Cliente no encontrado
        session.isNewClient = true;
        session.isAuthenticated = false;
        session.context = 'new_client';
        
        this.logger.log('üë§ Marcado como cliente nuevo: ' + session.phoneNumber);
      }
      
    } catch (error) {
      this.logger.error('‚ùå Error en autenticacion automatica: ' + error.message);
      this.logger.error('Stack: ' + error.stack);
      
      // En caso de error, tratar como cliente nuevo
      session.isNewClient = true;
      session.isAuthenticated = false;
      session.context = 'error_fallback';
      
      this.logger.log('üîÑ Fallback: Marcado como cliente nuevo por error');
    }
  }

  private async generateIntelligentWelcome(session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const currentHour = new Date().getHours();
      let timeGreeting = this.getTimeBasedGreeting(currentHour);
      
      if (session.isAuthenticated && !session.isNewClient) {
        // Cliente existente - saludo personalizado con an√°lisis de comportamiento
        const recentSearches = await this.getRecentSearches(session.phoneNumber, 5);
        const cartItems = await this.getActiveCartItems(session.phoneNumber);
        
        let personalizedMessage = `üéâ ${timeGreeting}, **${session.clientName}**! üåü\n`;
        personalizedMessage += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        personalizedMessage += `‚ú® ¬°Qu√© alegr√≠a tenerle de vuelta en **G√≥mezMarket**! ‚ú®\n\n`;
        
        // A√±adir informaci√≥n contextual inteligente
        if (cartItems.length > 0) {
          personalizedMessage += `üõí **CARRITO GUARDADO** üõí\n`;
          personalizedMessage += `üì¶ Tiene ${cartItems.length} producto(s) esper√°ndole\n`;
          personalizedMessage += `üíæ Todo guardado y listo para continuar\n\n`;
        }
        
        if (recentSearches.length > 0) {
          const lastSearch = recentSearches[0];
          const daysSinceLastSearch = Math.floor((Date.now() - lastSearch.createdAt.getTime()) / (1000 * 60 * 60 * 24));
          
          if (daysSinceLastSearch <= 7) {
            personalizedMessage += `üîç **B√öSQUEDAS RECIENTES** üîç\n`;
            personalizedMessage += `üí° ¬øBusca algo similar a "${lastSearch.originalSearchTerm}"?\n`;
            personalizedMessage += `üìà Tenemos nuevas ofertas disponibles\n\n`;
          }
        }
        
        personalizedMessage += `üéØ **¬øEN QU√â LE PUEDO AYUDAR HOY?** üéØ\n`;
        personalizedMessage += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
        personalizedMessage += `1Ô∏è‚É£ üîç **Consultar productos** ‚Üí Buscar ofertas\n`;
        personalizedMessage += `2Ô∏è‚É£ üí∞ **Ver mi saldo** ‚Üí Estado de cuenta\n`;
        personalizedMessage += `3Ô∏è‚É£ üìÑ **Historial facturas** ‚Üí Mis compras\n`;
        personalizedMessage += `4Ô∏è‚É£ üõí **Hacer un pedido** ‚Üí ¬°Comprar ahora!\n\n`;
        personalizedMessage += `üí¨ O simplemente escriba lo que necesita... üöÄ`;
        
        return personalizedMessage;
      } else {
        // Cliente nuevo - bienvenida impactante
        return `üéä ${timeGreeting}! üéä\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üåü **¬°BIENVENIDO A G√ìMEZMARKET!** üåü\n` +
               `ü§ñ Soy **G√≥mezBot**, su asistente personal\n\n` +
               `üéØ **PARA COMENZAR** üéØ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìù Ind√≠queme su **c√©dula o RIF**\n` +
               `‚ú® Le ofrecer√© un servicio personalizado\n` +
               `üöÄ ¬°Descubra nuestras ofertas exclusivas!\n\n` +
               `üìå **Ejemplo:** V12345678 o J408079305\n` +
               `üíé ¬°Su experiencia premium comienza aqu√≠! üíé`;
      }
    } catch (error) {
      this.logger.error(`Error generando bienvenida: ${error.message}`);
      return `üéâ ¬°BIENVENIDO A G√ìMEZMARKET! üéâ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `ü§ñ Soy **G√≥mezBot** üöÄ\n` +
             `‚ú® ¬øEn qu√© puedo ayudarle hoy? ‚ú®`;
    }
  }

  private getTimeBasedGreeting(hour: number): string {
    if (hour >= 6 && hour <= 11) return 'üåÖ ¬°BUENOS D√çAS';
    if (hour >= 12 && hour <= 18) return '‚òÄÔ∏è ¬°BUENAS TARDES';
    if (hour > 18 && hour <= 23) return 'üåô ¬°BUENAS NOCHES';
    return 'üåú ¬°BUENA MADRUGADA';
  }

  private async processIntelligentMessage(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      // Normalizar y analizar el mensaje
      const normalizedMessage = this.normalizeMessage(message);
      const messageIntent = await this.analyzeMessageIntent(normalizedMessage, session);
      
      this.logger.debug(`üß† Intenci√≥n detectada: ${messageIntent.type} (confianza: ${messageIntent.confidence})`);
      
      // Si est√° en proceso de registro, manejar el registro
      if (session.context === 'new_client_registration') {
        return await this.handleNewClientRegistration(message, session, chatbotId);
      }
      
      // Si es un cliente nuevo que no est√° autenticado, verificar si envi√≥ c√©dula
      if (session.context === 'new_client' && !session.isAuthenticated) {
        // PRIMERO verificar si el mensaje contiene una c√©dula
        if (messageIntent.type === 'identification') {
          this.logger.log(`üÜî C√âDULA DETECTADA EN CLIENTE NUEVO: ${messageIntent.entities.identification}`);
          return await this.handleClientIdentification(messageIntent.entities.identification, session, chatbotId);
        }
        
        // Si no es c√©dula, solicitar identificaci√≥n
        this.logger.log(`üë§ NUEVO CLIENTE - Solicitando identificaci√≥n`);
        return await this.generateNewClientWelcome(session);
      }
      
      // Si est√° en selecci√≥n de m√©todo de pago
      if (session.context === 'checkout_payment_selection') {
        if (message.toLowerCase().includes('cancelar')) {
          session.context = 'menu';
          await this.chatService.saveSession(session);
          return `üîÑ **CHECKOUT CANCELADO** üîÑ\n` +
                 `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
                 `‚Ü©Ô∏è Regresando al men√∫ principal\n` +
                 `üõí Su carrito se mantiene intacto\n\n` +
                 `üéØ **¬øQu√© desea hacer?**\n` +
                 `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
                 `üîç Seguir comprando\n` +
                 `üëÄ Ver carrito\n` +
                 `üí¨ Buscar productos`;
        }
        return await this.handlePaymentSelection(message, session, chatbotId);
      }

      // Nuevos contextos para validaci√≥n de pago m√≥vil
      if (session.context ===   'payment_bank_selection') {
        return await this.handleBankSelection(message, session, chatbotId);
      }

      if (session.context === 'payment_phone_input') {
        return await this.handlePaymentPhoneInput(message, session, chatbotId);
      }

      if (session.context === 'payment_cedula_input') {
        return await this.handlePaymentCedulaInput(message, session, chatbotId);
      }

      if (session.context === 'payment_reference_input') {
        return await this.handlePaymentReferenceInput(message, session, chatbotId);
      }

      // Manejo de b√∫squeda por listas
      if (session.context === 'product_search' && this.esListaProductos(message)) {
        return await this.handleProductListSearch(message, session, chatbotId);
      }
      
      // Procesar seg√∫n la intenci√≥n y contexto
      switch (messageIntent.type) {
        case 'product_search':
          return await this.handleIntelligentProductSearch(messageIntent.entities.searchTerm, session, chatbotId);
          
        case 'menu_option':
          return await this.handleMenuOption(messageIntent.entities.option, session, chatbotId);
          
        case 'cart_action':
          return await this.handleCartAction(messageIntent.entities.action, messageIntent.entities.product, session, chatbotId);
          
        case 'identification':
          return await this.handleClientIdentification(messageIntent.entities.identification, session, chatbotId);
          
        case 'greeting':
          return await this.handleGreeting(session, chatbotId);
          
        case 'help':
          return await this.handleHelpRequest(session, chatbotId);
          
        default:
          return await this.handleUnknownIntent(message, session, chatbotId);
      }
    } catch (error) {
      this.logger.error(`Error procesando mensaje inteligente: ${error.message}`);
      return await this.handleIntelligentError(error, chatbotId);
    }
  }

  private async handleIntelligentProductSearch(searchTerm: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      session.context = 'product_search';
      session.searchCount += 1;
      
      // Analizar si es una b√∫squeda compuesta (m√∫ltiples productos)
      const searchTerms = this.detectMultipleSearchTerms(searchTerm);
      
      if (searchTerms.length > 1) {
        return await this.handleMultipleProductSearch(searchTerms, session, chatbotId);
      }
      
      // Normalizar t√©rmino de b√∫squeda
      const normalizedSearchTerm = this.normalizeSearchTerm(searchTerm);
      
      // B√∫squeda inteligente con m√∫ltiples estrategias
      const searchStrategies = [
        // B√∫squeda exacta
        { term: normalizedSearchTerm, type: 'exact' },
        // B√∫squeda por palabras individuales
        { term: normalizedSearchTerm, type: 'words' },
        // B√∫squeda con sin√≥nimos (si implementas)
        // { term: await this.expandWithSynonyms(normalizedSearchTerm), type: 'synonyms' }
      ];
      
      let productos = [];
      let searchType = '';
      
      for (const strategy of searchStrategies) {
        productos = await this.searchProductsWithStrategy(strategy.term, strategy.type, chatbotId);
        if (productos.length > 0) {
          searchType = strategy.type;
          break;
        }
      }
      
      // Guardar b√∫squeda en historial y en contexto de sesi√≥n
      await this.saveSearchHistory(session, searchTerm, normalizedSearchTerm, productos.length, chatbotId);
      
      // Guardar resultados en el contexto de sesi√≥n para referencia futura
      if (productos.length > 0) {
        session.metadata = {
          ...session.metadata,
          lastSearchResults: productos.slice(0, 10).map(p => ({
            id: p.id || p.codigo,
            name: p.nombre,
            price: p.preciounidad
          }))
        };
      }
      
      if (productos.length === 0) {
        // Sugerir b√∫squedas alternativas basadas en historial
        const suggestions = await this.getSimilarSearchSuggestions(session.phoneNumber, normalizedSearchTerm);
        
        // Create a more natural no-results response with variations
        const noResultsIntros = [
          `No encontr√© "${searchTerm}" en el inventario actual.`,
          `Parece que no tenemos "${searchTerm}" disponible en este momento.`,
          `Lo siento, busqu√© "${searchTerm}" pero no encontr√© resultados.`,
          `No hay "${searchTerm}" en el inventario ahora mismo.`
        ];
        
        const intro = noResultsIntros[Math.floor(Math.random() * noResultsIntros.length)];
        let response = `‚ùì **${intro}**`;
        
        if (suggestions.length > 0) {
          response += `\n\nüí° ¬øQuiz√°s te interesen estas alternativas?\n`;
          suggestions.forEach((suggestion, index) => {
            response += `  ‚Ä¢ **${suggestion}**\n`;
          });
        }
        
        // Add helpful suggestions in a conversational tone with minimal formatting
        response += `\nüîç ¬øPodr√≠as intentar con otra marca o una descripci√≥n m√°s general? `;
        response += `Tambi√©n puedes escribir "**ayuda**" si necesitas m√°s opciones.`;
        
        return response;
      }
      
      // Formatear resultados con informaci√≥n inteligente
      return await this.formatIntelligentProductResults(productos, searchTerm, searchType, session);
      
    } catch (error) {
      this.logger.error(`Error en b√∫squeda inteligente: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Detecta si un t√©rmino contiene m√∫ltiples b√∫squedas separadas
   */
  private detectMultipleSearchTerms(searchTerm: string): string[] {
    // Patrones para detectar conjunciones y separadores
    const conjunctions = /\s+(y|tambien|tambi√©n|adem√°s|ademas|con)\s+/i;
    const productSeparators = /\s*[,.;]\s*/;
    
    // Verificar si hay conjunciones claras
    if (conjunctions.test(searchTerm)) {
      // Dividir por conjunciones pero mantener la estructura de frase
      return searchTerm
        .split(conjunctions)
        .filter(term => term.length > 2 && !['y', 'tambien', 'tambi√©n', 'adem√°s', 'ademas', 'con'].includes(term.toLowerCase()))
        .map(term => term.trim());
    }
    
    // Verificar si hay separadores
    if (productSeparators.test(searchTerm)) {
      // Dividir por separadores
      return searchTerm
        .split(productSeparators)
        .filter(term => term.length > 2)
        .map(term => term.trim());
    }
    
    // Si no se identifican m√∫ltiples b√∫squedas
    return [searchTerm];
  }
  
  /**
   * Procesa m√∫ltiples b√∫squedas de productos cuando el usuario pide varios a la vez
   */
  private async handleMultipleProductSearch(searchTerms: string[], session: PersistentSession, chatbotId: string): Promise<string> {
    this.logger.log(`üßÆ Procesando b√∫squeda m√∫ltiple con ${searchTerms.length} productos`);
    
    // Realizar b√∫squedas independientes para cada t√©rmino
    const results = await Promise.all(searchTerms.map(async (term) => {
      const normalizedTerm = this.normalizeSearchTerm(term);
      const productos = await this.searchProductsWithStrategy(normalizedTerm, 'exact', chatbotId);
      return {
        term,
        productos: productos.slice(0, 3), // Limitar a 3 resultados por t√©rmino
        found: productos.length > 0
      };
    }));
    
    // Contar resultados encontrados/no encontrados
    const found = results.filter(r => r.found).length;
    const notFound = results.length - found;
    
    // Construir respuesta amigable
    let response = '';
    
    // Introducci√≥n personalizada seg√∫n resultados
    if (found === results.length) {
      response = `¬°Genial! Encontr√© todos los productos que buscabas:\n\n`;
    } else if (found > 0) {
      response = `Encontr√© algunos de los productos que mencionaste:\n\n`;
    } else {
      response = `Lo siento, no encontr√© ninguno de los productos que mencionaste.\n\n`;
    }
    
    // Mostrar cada grupo de resultados
    let allProducts: any[] = [];
    
    results.forEach((result, index) => {
      if (result.found) {
        response += `üìå **${result.term}**:\n`;
        result.productos.forEach((p, i) => {
          const price = parseFloat(p.preciounidad || 0).toFixed(2);
          response += `   ${index+1}.${i+1}. ${p.nombre} - $${price}\n`;
          allProducts.push(p);
        });
        response += '\n';
      } else {
        response += `‚ùå No encontr√© "${result.term}"\n\n`;
      }
    });
    
    // Guardar todos los productos en el contexto para poder referenciarlos
    if (allProducts.length > 0) {
      session.metadata = {
        ...session.metadata,
        lastSearchResults: allProducts.map(p => ({
          id: p.id || p.codigo,
          name: p.nombre,
          price: p.preciounidad
        }))
      };
      
      // A√±adir call to action natural
      response += `\nPuedes decirme "quiero el 1.2" para seleccionar el segundo producto de la primera b√∫squeda, o especificar exactamente cu√°l de ellos te interesa.`;
    } else {
      response += `\nPor favor intenta con otros productos o con t√©rminos m√°s generales.`;
    }
    
    return response;
  }

  private async searchProductsWithStrategy(searchTerm: string, type: string, chatbotId?: string): Promise<any[]> {
    let query = '';
    let params = [];
    
    // üöÄ VERIFICAR SI ES CHATBOT TIPO "ECOMMERCE" PARA USAR CONSULTAS INTELIGENTES
    let isEcommerceChatbot = false;
    if (chatbotId) {
      try {
        const chatbotConfig = await this.getChatbotConfig(chatbotId);
        const chatbotType = chatbotConfig?.chatbotConfig?.type;
        isEcommerceChatbot = (chatbotType === 'ecommerce');
        
        this.logger.log(`üîç Chatbot ID: ${chatbotId}, Tipo: ${chatbotType}, Consultas Inteligentes: ${isEcommerceChatbot ? 'ACTIVADAS' : 'DESACTIVADAS'}`);
      } catch (error) {
        this.logger.warn(`Error obteniendo config del chatbot ${chatbotId}: ${error.message}`);
      }
    }
    
    // üß† USAR SISTEMA DE CONSULTAS INTELIGENTES SOLO PARA CHATBOTS ECOMMERCE
    if (isEcommerceChatbot) {
      try {
        this.logger.log(`üéØ ACTIVANDO CONSULTAS INTELIGENTES para b√∫squeda: "${searchTerm}"`);
        
        // Determinar el alias seg√∫n el tipo de b√∫squeda
        let queryAlias = '';
        let marca = undefined;
        
        switch (type) {
          case 'exact':
            queryAlias = 'consulta_inventario';
            break;
          case 'words':
            const words = searchTerm.split(' ').filter(word => word.length > 2);
            if (words.length > 1) {
              queryAlias = 'consulta_inventario_palabras_multiples';
            } else {
              queryAlias = 'consulta_inventario';
            }
            break;
          default:
            queryAlias = 'consulta_inventario';
        }
        
                 // Usar el sistema de consultas inteligentes
         const intelligentResults = await this.valeryDbService.obtenerProductosParaChatbot(
           searchTerm,
           { tipo: 'ecommerce', id: chatbotId }
         );
        
        this.logger.log(`üéØ CONSULTAS INTELIGENTES - "${searchTerm}" (${queryAlias}): ${intelligentResults.length} resultados`);
        return intelligentResults;
        
      } catch (error) {
        this.logger.error(`‚ùå Error en consultas inteligentes: ${error.message}`);
        // Fallback al sistema tradicional
        this.logger.log(`üîÑ Fallback al sistema tradicional para: "${searchTerm}"`);
      }
    }
    
    // üìä SISTEMA TRADICIONAL (para chatbots no-ecommerce o como fallback)
    this.logger.log(`üìä USANDO SISTEMA TRADICIONAL para b√∫squeda: "${searchTerm}" (tipo: ${type})`);
    
    switch (type) {
      case 'exact':
        query = `
          SELECT 
            i.codigo,
            i.nombre,
            i.preciounidad,
            i.alicuotaiva,
            i.existenciaunidad,
            (SELECT factorcambio FROM monedas WHERE codmoneda = '02' LIMIT 1) AS tasa_actual
          FROM inventario i
          WHERE (i.status = 'A' OR i.status = '1')
            AND i.existenciaunidad >= 2
            AND LOWER(TRANSLATE(i.nombre, '√±√°√©√≠√≥√∫√º√ë√Å√â√ç√ì√ö√ú', 'naeiouuNAEIOUU')) LIKE LOWER(TRANSLATE($1, '√±√°√©√≠√≥√∫√º√ë√Å√â√ç√ì√ö√ú', 'naeiouuNAEIOUU'))
          ORDER BY 
            CASE WHEN LOWER(TRANSLATE(i.nombre, '√±√°√©√≠√≥√∫√º√ë√Å√â√ç√ì√ö√ú', 'naeiouuNAEIOUU')) LIKE LOWER(TRANSLATE($2, '√±√°√©√≠√≥√∫√º√ë√Å√â√ç√ì√ö√ú', 'naeiouuNAEIOUU')) THEN 0 ELSE 1 END,
            i.existenciaunidad DESC,
            LENGTH(i.nombre),
            i.nombre
          LIMIT 20
        `;
        params = [`%${searchTerm}%`, `${searchTerm}%`];
        break;
        
      case 'words':
        const words = searchTerm.split(' ').filter(word => word.length > 2);
        if (words.length === 0) return [];
        
        // Construir condiciones y par√°metros correctamente
        const conditions = [];
        const wordParams = [];
        
        for (let i = 0; i < words.length; i++) {
          conditions.push(`LOWER(TRANSLATE(i.nombre, '√±√°√©√≠√≥√∫√º√ë√Å√â√ç√ì√ö√ú', 'naeiouuNAEIOUU')) LIKE LOWER(TRANSLATE($${i + 1}, '√±√°√©√≠√≥√∫√º√ë√Å√â√ç√ì√ö√ú', 'naeiouuNAEIOUU'))`);
          wordParams.push(`%${words[i]}%`);
        }
        
        query = `
          SELECT 
            i.codigo,
            i.nombre,
            i.preciounidad,
            i.alicuotaiva,
            i.existenciaunidad,
            (SELECT factorcambio FROM monedas WHERE codmoneda = '02' LIMIT 1) AS tasa_actual
          FROM inventario i
          WHERE (i.status = 'A' OR i.status = '1')
            AND i.existenciaunidad >= 2
            AND (${conditions.join(' OR ')})
          ORDER BY i.existenciaunidad DESC, i.nombre
          LIMIT 15
        `;
        params = wordParams;
        break;
    }
    
    const results = await this.valeryDbService.ejecutarQuery(query, params, chatbotId || '');
    this.logger.log(`üîç B√∫squeda "${searchTerm}" (${type}): ${results.length} resultados`);
    
    return results;
  }

  private async formatIntelligentProductResults(productos: any[], searchTerm: string, searchType: string, session: PersistentSession): Promise<string> {
    // Generate a more natural response with some variations
    const introVariations = [
      `Encontr√© ${productos.length} ${productos.length === 1 ? 'resultado' : 'resultados'} para "${searchTerm}":`,
      `Aqu√≠ tienes lo que encontr√© sobre "${searchTerm}":`,
      `Para tu b√∫squeda "${searchTerm}", tenemos disponible:`,
      `Mira lo que tenemos para "${searchTerm}":`,
      `Revis√© el inventario y encontr√© ${productos.length} ${productos.length === 1 ? 'opci√≥n' : 'opciones'} de "${searchTerm}":`,
    ];
    
    // Randomly select an introduction
    const intro = introVariations[Math.floor(Math.random() * introVariations.length)];
    
    // Add some icon at the beginning but keep it simple and clean
    let respuesta = `üõçÔ∏è ${intro}\n\n`;
    
    // Create a more natural product listing with visual enhancers
    for (let i = 0; i < productos.length; i++) {
      const p = productos[i];
      if (!p.nombre || !p.preciounidad || !p.tasa_actual) continue;

      const precioUSD = (parseFloat(p.preciounidad) || 0).toFixed(2);
      const precioBs = this.calcularPrecioBs(p.preciounidad, p.alicuotaiva, p.tasa_actual).toFixed(2);

      respuesta += `üìå **Producto ${i + 1}: ${p.nombre}**\n`;
      respuesta += `   üíµ **$${precioUSD}** (Bs ${precioBs})\n\n`;
    }
    
    // Add contextual information based on search type but in a more natural way
    if (searchType === 'words') {
      respuesta += `Esta b√∫squeda se realiz√≥ por palabras clave.\n\n`;
    }
    
    // Add call to action in a more natural way
    const ctaVariations = [
      "¬øCu√°l te gustar√≠a agregar? Puedes decirme \"quiero el n√∫mero 1\" o \"agregar el 2 al carrito\".",
      "Si te interesa alguno, dime el n√∫mero o nombre del que quieres.",
      "Dime cu√°l prefieres usando el n√∫mero o indic√°ndome directamente cu√°l quieres.",
      "¬øAlguno te interesa? Ind√≠came el n√∫mero o dime \"agregar el producto X\"."
    ];
    
    // Randomly select a call to action
    const cta = ctaVariations[Math.floor(Math.random() * ctaVariations.length)];
    
    respuesta += `üõí ${cta}`;
    
    // Add a natural closer if needed
    if (Math.random() > 0.5) {
      respuesta += "\n\nüîç Si necesitas ver m√°s opciones, puedes refinar tu b√∫squeda.";
    }
    
    return respuesta;
  }

  // Funci√≥n para calcular precio en Bs con IVA y redondear al m√∫ltiplo m√°s cercano
  private calcularPrecioBs(precioUSD: number | string, alicuota: number | string, tasa: number | string): number {
    const base = Number(precioUSD) || 0;
    const iva = Number(alicuota) || 0;
    const tasaCambio = Number(tasa) || 1;
    const conIVA = base * (1 + (iva / 100));
    const bs = conIVA * tasaCambio;
    return Math.round(bs * 10) / 10; // redondeo al m√∫ltiplo de 0.10
  }

  private normalizeMessage(message: string): string {
    return message.toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^\w\s]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  private normalizeSearchTerm(term: string): string {
    return term.toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^\w\s]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  private async analyzeMessageIntent(message: string, session: PersistentSession): Promise<any> {
    this.logger.log(`üîç ANALIZANDO MENSAJE: "${message}"`);
    
    // An√°lisis mejorado de intenciones con m√°s patrones conversacionales
    const patterns = {
      product_search: [
        // Patrones b√°sicos
        /busco?|buscar|necesito|quiero(?!\s+(el|la|los|las|al)?\s+(\d|producto|item))|dame|tienes?|hay|vendo?|vender/,
        /producto(?!\s+\d)|marca|presentacion|litro|kilo|gramo|paquete/,
        // Patrones conversacionales
        /(?:tienen|venden|consigo|hay|encuentro|vendes)\s+(?:algo|productos?)?(?:\s+de|\s+para|\s+como|\s+tipo)?/i,
        /(?:cu√°nto|cuanto|precio|cuesta|vale|valor)\s+(?:el|la|los|las|un|una|unos|unas)?/i,
        /(?:quisiera|me\s+gustar√≠a|me\s+gustaria|me\s+interesa|busco)\s+(?:un|una|unos|unas|el|la|los|las)?/i,
        /(?:d√≥nde|donde)\s+(?:encuentro|consigo|tienen|hay|ubico)/i,
        /(?:me\s+muestras?|me\s+ense√±as?|puedes?\s+mostrarme|podrian\s+mostrarme)/i,
        // Multi-producto (buscar varios productos a la vez)
        /(?:y|tambi√©n|tambien|adem√°s|ademas)\s+(?:un|una|unos|unas)?/i
      ],
      menu_option: [
        /^[1-4]$|^[1-4]Ô∏è‚É£$|saldo|factura|pedido(?!\s)|historial/
      ],
      cart_action: [
        // Patrones b√°sicos de carrito
        /carrito|agregar|a√±adir|quitar|eliminar|comprar(?!\s)|finalizar|proceder/,
        /quiero\s+(el|la|los|las)?\s*(producto|item)?\s*\d+|agregar\s+(el|la)?\s*(producto|item)?\s*\d+|producto\s+\d+\s+al\s+carrito/,
        /ver\s+carrito|mi\s+carrito|vaciar\s+carrito|limpiar\s+carrito/,
        // Patrones conversacionales de carrito
        /(?:ponme|agregame|a√±ademe|sumame|echame)\s+(?:un|una|unos|unas|el|la|los|las)?/i,
        /(?:me\s+llevo|me\s+gustaria\s+llevar|me\s+quedaria\s+con)\s+(?:el|la|los|las|este|esta|estos|estas)?/i,
        /(?:llevare|llevo|tomare|tomo)\s+(?:el|la|los|las|este|esta)?/i,
        /(?:deme|dame|d√©me|d√°melo)\s+(?:un|una|el|la)?/i,
        // Interacci√≥n con n√∫mero de producto con lenguaje natural
        /(?:el|la|los|las)?\s*(?:numero|n√∫mero|num|n√∫m)?\s*(\d+)/i,
        /(?:quiero|dame|deme|llevo)?\s+(\d+)\s+(?:de esos|de estos|de este|de ese)/i
      ],
      identification: [
        /\b[vVeEjJpP]?-?[0-9]{6,9}\b/,  // Detectar c√©dulas en cualquier parte del mensaje
        /\b[0-9]{7,9}\b/,  // Detectar c√©dulas solo n√∫meros en cualquier parte
        /cedula.*[vVeEjJpP]?-?[0-9]{6,9}/i,  // Detectar "cedula V12345678"
        /[vVeEjJpP][0-9]{7,9}/  // Formato directo V12345678
      ],
      greeting: [
        /hola|buenos?|buenas?|saludos|hey|hi|qu√©\s+tal|como\s+est√°s|como\s+va|que\s+tal/i
      ],
      help: [
        /ayuda|help|como|que puedo|opciones|menu|gu√≠a|guia|instrucciones|comando|asistencia/i
      ]
    };
    
    // Sistema de priorizaci√≥n contextual basado en el contexto actual
    const contextPriority = {
      'product_search': ['cart_action', 'product_search'],
      'cart_checkout': ['cart_action', 'help'],
      'new_client': ['identification', 'greeting'],
      'default': ['product_search', 'cart_action', 'greeting', 'help', 'identification', 'menu_option']
    };
    
    // Seleccionar la prioridad seg√∫n contexto
    const priorityOrder = contextPriority[session.context] || contextPriority.default;
    
    // 1. Primera pasada: verificamos coincidencias seg√∫n la prioridad
    let matchFound = false;
    let bestMatch = { type: 'unknown', confidence: 0, entities: {} };
    
    // Analizar seg√∫n orden de prioridad
    for (const intentType of priorityOrder) {
      if (matchFound) break;
      
      const regexList = patterns[intentType];
      if (!regexList) continue;
      
      for (const regex of regexList) {
        if (regex.test(message)) {
          const confidence = this.calculateIntentConfidence(message, intentType, session);
          if (confidence > bestMatch.confidence) {
            bestMatch = {
              type: intentType,
              confidence,
              entities: this.extractEntities(message, intentType, session)
            };
            
            // Si tenemos alta confianza (>0.8), podemos terminar la b√∫squeda
            if (confidence > 0.8) {
              matchFound = true;
              break;
            }
          }
        }
      }
    }
    
    // Si no encontramos coincidencia con alta confianza, considerar el contexto de sesi√≥n actual
    if (bestMatch.confidence < 0.6 && session.context === 'product_search') {
      // En contexto de b√∫squeda, casi cualquier mensaje podr√≠a ser una b√∫squeda
      bestMatch = {
        type: 'product_search',
        confidence: 0.7,
        entities: { searchTerm: message }
      };
    }
    
    // Log para depuraci√≥n
    this.logger.log(`üéØ RESULTADO AN√ÅLISIS: type="${bestMatch.type}", confidence=${bestMatch.confidence}, entities=${JSON.stringify(bestMatch.entities)}`);
    
    return bestMatch;
  }

  /**
   * Calcula la confianza de la intenci√≥n detectada considerando contexto y longitud
   */
  private calculateIntentConfidence(message: string, intentType: string, session: PersistentSession): number {
    // Base de confianza por tipo de intenci√≥n
    const baseConfidence = {
      'product_search': 0.7,
      'cart_action': 0.75,
      'greeting': 0.9,
      'help': 0.85,
      'identification': 0.9,
      'menu_option': 0.8,
      'unknown': 0.3
    }[intentType] || 0.5;
    
    // Factor de longitud - mensajes m√°s elaborados tienen m√°s confianza
    const lengthFactor = Math.min(message.length / 15, 1) * 0.15;
    
    // Factor de contexto - si el mensaje coincide con el contexto actual, m√°s confianza
    const contextFactor = (session.context === 'product_search' && intentType === 'product_search') ? 0.1 :
                         (session.context === 'cart_checkout' && intentType === 'cart_action') ? 0.1 : 0;
    
    // C√°lculo final limitado a 1.0 m√°ximo
    return Math.min(baseConfidence + lengthFactor + contextFactor, 1.0);
  }

  /**
   * Extrae entidades relevantes del mensaje seg√∫n la intenci√≥n
   */
  private extractEntities(message: string, intentType: string, session: PersistentSession): any {
    const entities: any = {};
    
    switch (intentType) {
      case 'product_search':
        // Extracci√≥n mejorada para t√©rminos de b√∫squeda
        // 1. Eliminar palabras comunes del inicio
        const stopWords = [
          'busco', 'necesito', 'quiero', 'dame', 'tienes', 'hay', 'me', 'puedes', 'dar',
          'tienen', 'venden', 'consigo', 'encuentro', 'quisiera', 'me gustar√≠a', 
          'quisiera', 'mu√©strame', 'h√°blame de', 'informaci√≥n sobre', 'busca'
        ];
        
        let cleanedMessage = message.toLowerCase();
        
        // Eliminar palabras iniciales comunes
        for (const word of stopWords) {
          if (cleanedMessage.startsWith(word)) {
            cleanedMessage = cleanedMessage.substring(word.length).trim();
            break;
          }
        }
        
        // 2. Eliminar prefijos comunes
        const prefixes = ['un ', 'una ', 'unos ', 'unas ', 'el ', 'la ', 'los ', 'las ', 'del ', 'de la ', 'de los ', 'de las '];
        for (const prefix of prefixes) {
          if (cleanedMessage.startsWith(prefix)) {
            cleanedMessage = cleanedMessage.substring(prefix.length).trim();
            break;
          }
        }
        
        // 3. Limpiar palabras vac√≠as y signos
        entities.searchTerm = cleanedMessage
          .replace(/[¬ø?¬°!.,;:]/g, '') // Eliminar signos de puntuaci√≥n
          .replace(/\s+/g, ' ')       // Normalizar espacios
          .trim();
        break;
        
      case 'menu_option':
        const optionMatch = message.match(/[1-4]/);
        entities.option = optionMatch ? optionMatch[0] : null;
        break;

      case 'cart_action':
        // Detectar la acci√≥n espec√≠fica del carrito
        if (/(agregar|a√±adir|poner|meter|llevar|quiero|dame|deme)/i.test(message)) {
          entities.action = "agregar";
        } else if (/(ver|mostrar|mirar|revisar|carrito)/i.test(message)) {
          entities.action = "ver carrito";
        } else if (/(quitar|eliminar|remover|sacar|borrar|cancelar)/i.test(message)) {
          entities.action = "quitar";
        } else if (/(vaciar|limpiar)/i.test(message)) {
          entities.action = "vaciar";
        } else if (/(comprar|pagar|checkout|proceder|finalizar)/i.test(message)) {
          entities.action = "comprar";
        } else {
          entities.action = message.toLowerCase();
        }
        
        // Extraer informaci√≥n del producto
        const productMatch = message.match(/(?:producto|item|n√∫mero|numero|num|n√∫m)\s*(\d+)/i);
        const simpleNumberMatch = message.match(/\b(\d+)\b/);
        
        if (productMatch) {
          entities.product = productMatch[1];
        } else if (simpleNumberMatch && entities.action === "agregar") {
          entities.product = simpleNumberMatch[1];
        }
        
        // Extraer cantidad si existe
        const quantityMatch = message.match(/(\d+)\s+(?:unidades|productos|unidad|producto)/i);
        if (quantityMatch) {
          entities.quantity = parseInt(quantityMatch[1]);
        }
        break;
        
      case 'identification':
        // Mejorar detecci√≥n de c√©dulas
        const cedulaPatterns = [
          /\b([vVeEjJpP]?-?[0-9]{6,9})\b/,
          /cedula.*?([vVeEjJpP]?-?[0-9]{6,9})/i,
          /([vVeEjJpP][0-9]{7,9})/
        ];
        
        for (const pattern of cedulaPatterns) {
          const match = message.match(pattern);
          if (match) {
            entities.identification = match[1].replace(/[^a-zA-Z0-9]/g, '');
            break;
          }
        }
        
        // Si no se encontr√≥ con patrones espec√≠ficos
        if (!entities.identification) {
          const numerosEncontrados = message.match(/\d{6,9}/);
          if (numerosEncontrados) {
            entities.identification = numerosEncontrados[0];
          } else {
            entities.identification = message.replace(/[^a-zA-Z0-9]/g, '');
          }
        }
        break;
        
      case 'greeting':
        // Detectar si es saludo inicial o en medio de conversaci√≥n
        entities.isInitial = session.messageCount < 3;
        entities.time = this.getTimeOfDay();
        break;
        
      case 'help':
        // Identificar tipo espec√≠fico de ayuda solicitada
        if (/(?:como|c√≥mo)\s+(?:comprar|pagar|buscar|agregar)/i.test(message)) {
          entities.helpType = 'proceso';
        } else if (/(?:opciones|comandos|instrucciones)/i.test(message)) {
          entities.helpType = 'comandos';
        } else {
          entities.helpType = 'general';
        }
        break;
    }
    
    return entities;
  }
  
  /**
   * Obtiene el momento del d√≠a para contextualizar saludos
   */
  private getTimeOfDay(): string {
    const hour = new Date().getHours();
    if (hour >= 5 && hour < 12) return 'ma√±ana';
    if (hour >= 12 && hour < 18) return 'tarde';
    return 'noche';
  }

  private async handleMenuOption(option: string, session: PersistentSession, chatbotId: string): Promise<string> {
    if (!session.isAuthenticated) {
      return `üîê **AUTENTICACI√ìN REQUERIDA** üîê\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üö´ Debe identificarse primero\n` +
             `üìù Ingrese su c√©dula o RIF\n` +
             `‚ú® ¬°Acceso personalizado garantizado! ‚ú®`;
    }
    
    switch (option) {
      case '1':
        session.context = 'product_search';
        return `üîç **¬°B√öSQUEDA DE PRODUCTOS!** üîç\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üéØ ¬øQu√© producto busca?\n` +
               `üí° Puede escribir:\n` +
               `‚ñ™Ô∏è Nombre del producto\n` +
               `‚ñ™Ô∏è Marca espec√≠fica\n` +
               `‚ñ™Ô∏è Categor√≠a\n\n` +
               `üìù **Ejemplos:**\n` +
               `ü•õ "leche completa"\n` +
               `üçû "pan integral"\n` +
               `üß¥ "champ√∫ beb√©"\n\n` +
               `üöÄ ¬°Escriba y descubra nuestras ofertas! üöÄ`;
        
      case '2':
        return await this.getSaldoCliente(session);
        
      case '3':
        return `üìÑ **HISTORIAL DE FACTURAS** üìÑ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üöß Funcionalidad en desarrollo\n` +
               `‚öôÔ∏è Pr√≥ximamente disponible\n` +
               `üìû Mientras tanto, contacte servicio\n` +
               `üîÑ ¬°Trabajamos para mejorar! üîÑ`;
        
      case '4':
        session.context = 'order_start';
        return `üõí **¬°CREAR NUEVO PEDIDO!** üõí\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üéØ **OPCIONES DISPONIBLES:**\n\n` +
               `1Ô∏è‚É£ üîç **Buscar productos**\n` +
               `    ‚Üí Explorar cat√°logo\n\n` +
               `2Ô∏è‚É£ üìù **Lista de productos**\n` +
               `    ‚Üí Escribir lo que necesita\n\n` +
               `üí° **¬øQu√© productos necesita?**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üí¨ Escriba y comencemos... üöÄ`;
        
      default:
        return `‚ùå **OPCI√ìN NO V√ÅLIDA** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üî¢ Seleccione del 1 al 4\n` +
               `üí° Use los n√∫meros del men√∫\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
    }
  }

  private async getSaldoCliente(session: PersistentSession): Promise<string> {
    try {
      if (!session.clientId) {
        return `‚ùå **ERROR DE CUENTA** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üö´ No se encontr√≥ informaci√≥n\n` +
               `üìû Contacte servicio al cliente\n` +
               `üÜò ¬°Estamos aqu√≠ para ayudarle! üÜò`;
      }
      
      const query = `
        SELECT 
          c.nombre,
          c.tienecredito,
          c.diascredito,
          c.saldo,
          c.fechaultimaventa
        FROM clientes c
        WHERE c.codigocliente = $1
      `;
      
      const results = await this.valeryDbService.ejecutarQuery(query, [session.clientId], '');
      
      if (results && results.length > 0) {
        const cliente = results[0];
        
        let respuesta = `üí∞ **ESTADO DE CUENTA** üí∞\n`;
        respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        respuesta += `üë§ **Cliente:** ${cliente.nombre}\n`;
        respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
        
        if (!cliente.tienecredito) {
          respuesta += `üí≥ **MODALIDAD DE PAGO** üí≥\n`;
          respuesta += `üìã Tipo: **CONTADO**\n`;
          respuesta += `üö´ Sin l√≠nea de cr√©dito activa\n`;
          respuesta += `üí∞ Pagos inmediatos requeridos\n\n`;
        } else {
          respuesta += `üè¶ **CUENTA DE CR√âDITO** üè¶\n`;
          respuesta += `üìã Modalidad: **CR√âDITO**\n`;
          respuesta += `‚è∞ Plazo: ${cliente.diascredito} d√≠as\n`;
          respuesta += `üí∞ **Saldo actual:** ${this.formatearPrecio(cliente.saldo)}\n`;
          
          if (cliente.saldo > 0) {
            respuesta += `‚ö†Ô∏è **SALDO PENDIENTE** ‚ö†Ô∏è\n`;
          } else {
            respuesta += `‚úÖ **¬°AL D√çA CON PAGOS!** ‚úÖ\n`;
          }
          respuesta += `\n`;
        }
        
        if (cliente.fechaultimaventa) {
          const diasUltimaCompra = Math.floor((Date.now() - new Date(cliente.fechaultimaventa).getTime()) / (1000 * 60 * 60 * 24));
          respuesta += `üõçÔ∏è **√öLTIMA COMPRA** üõçÔ∏è\n`;
          respuesta += `üìÖ Hace ${diasUltimaCompra} d√≠as\n`;
          respuesta += `üîÑ ¬°Esperamos su pr√≥xima visita!\n\n`;
        }
        
        respuesta += `üéØ **¬øQU√â DESEA HACER?** üéØ\n`;
        respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        respuesta += `üõí ¬°Realizar una nueva compra!\n`;
        respuesta += `üìû Contactar servicio al cliente\n`;
        respuesta += `üí¨ ¬°Estoy aqu√≠ para ayudarle! üöÄ`;
        
        return respuesta;
      } else {
        return `‚ùå **ERROR DE CONSULTA** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üö´ No se pudo obtener informaci√≥n\n` +
               `üìû Contacte servicio al cliente\n` +
               `üÜò Error ID: ${Date.now().toString(36)} üÜò`;
      }
    } catch (error) {
      this.logger.error(`Error consultando saldo: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error consultando saldo\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private async handleClientIdentification(identification: string, session: PersistentSession, chatbotId: string): Promise<string> {
    return await this.authenticateClientByCedula(identification, session, chatbotId);
  }

  private async authenticateClientByCedula(cedula: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const normalizedCedula = this.normalizeIdentification(cedula);
      
      const query = `
        SELECT 
          c.codigocliente,
          c.nombre,
          c.rif,
          c.direccion1,
          c.telefono1,
          c.telefono2,
          c.tienecredito,
          c.diascredito,
          c.saldo,
          c.status
        FROM clientes c
        WHERE c.rif = $1 OR c.rif = $2
        LIMIT 1
      `;
      
      const results = await this.valeryDbService.ejecutarQuery(query, [normalizedCedula, `V${normalizedCedula}`], chatbotId);
      
      if (results && results.length > 0) {
        const cliente = results[0];
        
        // Actualizar sesi√≥n
        session.clientId = cliente.codigocliente;
        session.clientName = cliente.nombre;
        session.identificationNumber = normalizedCedula;
        session.isAuthenticated = true;
        session.isNewClient = false;
        session.context = 'menu';
        
        await this.chatService.saveSession(session);
        
        return `üéâ **¬°IDENTIFICACI√ìN EXITOSA!** üéâ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚úÖ **¬°Bienvenido ${cliente.nombre}!** ‚úÖ\n` +
               `üîê Autenticado correctamente\n` +
               `üåü ¬°Listo para atenderle!\n\n` +
               `üéØ **¬øC√ìMO LE PUEDO AYUDAR?** üéØ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n` +
               `1Ô∏è‚É£ üîç **Consultar productos** ‚Üí Ver cat√°logo\n` +
               `2Ô∏è‚É£ üí∞ **Ver mi saldo** ‚Üí Estado cuenta\n` +
               `3Ô∏è‚É£ üìÑ **Historial facturas** ‚Üí Mis compras\n` +
               `4Ô∏è‚É£ üõí **Hacer un pedido** ‚Üí ¬°Primera compra!\n\n` +
               `üí¨ O escriba directamente lo que necesita... üöÄ`;
      } else {
        // Cliente no encontrado - iniciar proceso de registro
        session.identificationNumber = normalizedCedula;
        session.isNewClient = true;
        session.isAuthenticated = false;
        session.context = 'new_client_registration';
        
        await this.chatService.saveSession(session);
        
        return `üÜï **¬°NUEVO CLIENTE DETECTADO!** üÜï\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìã C√©dula/RIF: ${normalizedCedula}\n` +
               `üö´ No existe en nuestros registros\n\n` +
               `‚ú® **¬°REGISTREMOS SU CUENTA!** ‚ú®\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üéÅ Proceso r√°pido y ofertas especiales\n` +
               `üîí Sus datos est√°n seguros con nosotros\n\n` +
               `üìù **PASO 1 DE 1:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üë§ Por favor, escriba su **NOMBRE COMPLETO**\n` +
               `üí° Ejemplo: "Juan Carlos P√©rez Gonz√°lez"\n\n` +
               `üöÄ ¬°Su experiencia premium comienza aqu√≠! üöÄ`;
      }
    } catch (error) {
      this.logger.error(`Error autenticando por c√©dula: ${error.message}`);
      return `‚ùå **ERROR DE VERIFICACI√ìN** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error t√©cnico temporal\n` +
             `‚è∞ Intente nuevamente\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private normalizeIdentification(cedula: string): string {
    return cedula.replace(/[^\d]/g, '');
  }

  private async handleGreeting(session: PersistentSession, chatbotId: string): Promise<string> {
    if (session.isAuthenticated) {
      return `üéâ **¬°HOLA DE NUEVO!** üéâ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üòä ${session.clientName}\n` +
             `‚ú® ¬°Qu√© gusto saludarle!\n\n` +
             `üéØ **¬øEN QU√â LE AYUDO HOY?** üéØ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üí¨ ¬°Estoy aqu√≠ para servirle! üöÄ`;
    } else {
      return `üëã **¬°HOLA Y BIENVENIDO!** üëã\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üåü **G√≥mezMarket** a su servicio\n` +
             `ü§ñ Soy **G√≥mezBot**\n\n` +
             `üîê **PARA COMENZAR:**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üìù Indique su c√©dula o RIF\n` +
             `‚ú® ¬°Servicio personalizado garantizado! ‚ú®`;
    }
  }

  private async handleHelpRequest(session: PersistentSession, chatbotId: string): Promise<string> {
    let helpMessage = `üÜò **¬°CENTRO DE AYUDA!** üÜò\n`;
    helpMessage += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
    helpMessage += `ü§ñ **G√≥mezBot** - Su asistente\n\n`;
    helpMessage += `üí¨ **COMANDOS DISPONIBLES:**\n`;
    helpMessage += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
    helpMessage += `üîç **Buscar:** "busco aceite" o "necesito arroz"\n`;
    helpMessage += `üî¢ **Opciones:** Escriba n√∫meros 1-4\n`;
    helpMessage += `üõí **Carrito:** "agregar producto 1"\n`;
    helpMessage += `üëÄ **Ver carrito:** "mi carrito"\n\n`;
    
    if (session.isAuthenticated) {
      helpMessage += `üéØ **SUS OPCIONES:**\n`;
      helpMessage += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      helpMessage += `1Ô∏è‚É£ üîç **Consultar productos**\n`;
      helpMessage += `2Ô∏è‚É£ üí∞ **Ver saldo**\n`;
      helpMessage += `3Ô∏è‚É£ üìÑ **Historial**\n`;
      helpMessage += `4Ô∏è‚É£ üõí **Hacer pedido**\n\n`;
    }
    
    helpMessage += `üß† **¬°INTELIGENCIA ARTIFICIAL!**\n`;
    helpMessage += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
    helpMessage += `üí¨ Escriba naturalmente\n`;
    helpMessage += `ü§ñ ¬°Entiendo su lenguaje!\n`;
    helpMessage += `üöÄ ¬°Estoy aqu√≠ para ayudarle! üöÄ`;
    
    return helpMessage;
  }

  private async handleUnknownIntent(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    // Si no se entiende el mensaje, intentar una b√∫squeda de productos
    if (message.length > 3) {
      return await this.handleIntelligentProductSearch(message, session, chatbotId);
    }
    
    return `ü§î **¬øPODR√çA SER M√ÅS ESPEC√çFICO?** ü§î\n` +
           `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
           `‚ùì No entend√≠ completamente\n\n` +
           `üí° **PUEDE INTENTAR:**\n` +
           `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
           `üîç Buscar productos espec√≠ficos\n` +
           `üìù Escribir n√∫meros 1-4 para opciones\n` +
           `üÜò Escribir "ayuda" para m√°s info\n\n` +
           `üí¨ ¬°Escriba naturalmente! üöÄ`;
  }

  private async handleIntelligentError(error: Error, chatbotId: string): Promise<string> {
    const errorId = Date.now().toString(36);
    this.logger.error(`Error ID ${errorId}: ${error.message}`);
    
    return `üòÖ **¬°UPS! INCONVENIENTE T√âCNICO** üòÖ\n` +
           `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
           `üîß Peque√±o problema temporal\n` +
           `‚ö° Nuestro equipo ya fue notificado\n\n` +
           `üÜî **ID de error:** ${errorId}\n\n` +
           `üîÑ **¬øQU√â PUEDE HACER?**\n` +
           `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
           `‚è∞ Intente nuevamente\n` +
           `üìû Contacte soporte si persiste\n` +
           `üöÄ ¬°Estamos aqu√≠ para ayudarle! üöÄ`;
  }

  // M√©todos auxiliares para persistencia
  private async saveMessage(session: PersistentSession, userMessage: string, botResponse: string): Promise<void> {
    try {
      // Guardar mensaje del usuario
      await this.chatService.saveMessage(session, userMessage, 'user');
      
      // Guardar respuesta del bot
      await this.chatService.saveMessage(session, botResponse, 'assistant');
    } catch (error) {
      this.logger.error(`Error guardando mensajes: ${error.message}`);
    }
  }

  private async saveSearchHistory(session: PersistentSession, originalTerm: string, normalizedTerm: string, resultsCount: number, chatbotId: string): Promise<void> {
    try {
      await this.chatService.saveSearchHistory(session, originalTerm, normalizedTerm, resultsCount, chatbotId);
    } catch (error) {
      this.logger.error(`Error guardando historial de b√∫squeda: ${error.message}`);
    }
  }

  private async getRecentSearches(phoneNumber: string, limit: number = 5): Promise<SearchHistory[]> {
    try {
      return await this.chatService.findRecentSearches(phoneNumber, limit);
    } catch (error) {
      this.logger.error(`Error obteniendo b√∫squedas recientes: ${error.message}`);
      return [];
    }
  }

  private async getActiveCartItems(phoneNumber: string): Promise<ShoppingCart[]> {
    try {
      return await this.chatService.findActiveCartItems(phoneNumber);
    } catch (error) {
      this.logger.error(`Error obteniendo carrito: ${error.message}`);
      return [];
    }
  }

  private async getSimilarSearchSuggestions(phoneNumber: string, searchTerm: string, limit: number = 3): Promise<string[]> {
    try {
      const recentSearches = await this.chatService.findSimilarSearchSuggestions(phoneNumber, searchTerm, limit);
      
      return recentSearches.map(row => row.term);
    } catch (error) {
      this.logger.error(`Error obteniendo sugerencias: ${error.message}`);
      return [];
    }
  }

  private async cleanInactiveSessions(): Promise<void> {
    try {
      const cutoffDate = new Date(Date.now() - this.SESSION_TIMEOUT);
      
      const result = await this.chatService.cleanInactiveSessions(cutoffDate);
      
      if (result.affected > 0) {
        this.logger.debug(`üßπ Marcadas ${result.affected} sesiones como inactivas`);
      }
    } catch (error) {
      this.logger.error(`Error limpiando sesiones inactivas: ${error.message}`);
    }
  }

  private formatearPrecio(precio: number): string {
    return new Intl.NumberFormat('es-VE', { style: 'currency', currency: 'USD' }).format(precio);
  }

  // M√©todos adicionales que se pueden implementar...
  private async handleCartAction(action: string, product: string, session: PersistentSession, chatbotId: string): Promise<string> {
    this.logger.log(`üõí Acci√≥n de carrito: ${action}, Producto: ${product}, Usuario: ${session.phoneNumber}`);
    
    try {
      if (action.includes('agregar') || action.includes('a√±adir') || action.includes('quiero')) {
        // Extraer n√∫mero de producto y cantidad
        const { productNumber, quantity } = this.extractProductNumber(action);
        
        if (productNumber === null) {
          return `‚ùå **PRODUCTO NO ESPECIFICADO** ‚ùå\n` +
                 `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
                 `üî¢ Especifique el n√∫mero del producto\n` +
                 `üí° Ejemplo: "Agregar producto 1 al carrito"\n` +
                 `üí° Ejemplo: "Quiero el producto 3"\n` +
                 `üí° Ejemplo: "Agregar 2 del producto 3"\n\n` +
                 `üîÑ ¬°Intente nuevamente! üîÑ`;
        }

        return await this.addProductToCart(productNumber, session, chatbotId, quantity);
      }
      
      if (action.includes('ver') || action.includes('mostrar') || action.includes('carrito')) {
        return await this.showCart(session);
      }
      
      if (action.includes('quitar') || action.includes('eliminar') || action.includes('remover')) {
        const { productNumber } = this.extractProductNumber(action);
        return await this.removeProductFromCart(productNumber, session);
      }
      
      if (action.includes('vaciar') || action.includes('limpiar')) {
        return await this.clearUserCart(session);
      }
      
      if (action.includes('comprar') || action.includes('pagar') || action.includes('checkout')) {
        return await this.proceedToCheckout(session, chatbotId);
      }
      
      return `üõí **ACCI√ìN DE CARRITO NO RECONOCIDA** üõí\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `‚ùì No entend√≠ la acci√≥n solicitada\n\n` +
             `üîß **ACCIONES DISPONIBLES:**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `‚ûï Agregar producto [n√∫mero] al carrito\n` +
             `üëÄ Ver mi carrito\n` +
             `‚ûñ Quitar producto [n√∫mero]\n` +
             `üóëÔ∏è Vaciar carrito\n` +
             `üí≥ Proceder a comprar\n\n` +
             `üí¨ ¬°Escriba una de estas opciones! üöÄ`;
    } catch (error) {
      this.logger.error(`Error en acci√≥n de carrito: ${error.message}`, error.stack);
      
      return `‚ùå **ERROR EN CARRITO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß No se pudo procesar la acci√≥n solicitada\n` +
             `‚ö†Ô∏è ${error.message}\n\n` +
             `üîÑ **SUGERENCIAS:**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîç Verifique el n√∫mero de producto\n` +
             `üìù Intente con otra b√∫squeda primero\n` +
             `üëÄ Escriba "ver carrito" para verificar\n\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Extrae el n√∫mero de producto y cantidad desde un mensaje conversacional
   * Soporta m√∫ltiples formatos naturales de referencia a productos
   */
  private extractProductNumber(message: string): { productNumber: number | null, quantity: number } {
    // Valor por defecto para la cantidad
    let quantity = 1;
    
    // Normalizar mensaje para facilitar detecci√≥n
    const normalizedMsg = message.toLowerCase();
    
    // Patrones para multi-producto (formato 1.2 para producto 2 de la b√∫squeda 1)
    const multiProductPattern = /(?:quiero|dame|llevo|agrega[r]?|a√±adir|poner)\s+(?:el|la)?\s*(\d+)\.(\d+)/i;
    const multiMatch = message.match(multiProductPattern);
    if (multiMatch) {
      // Formato especial para multi-b√∫squeda
      const group = parseInt(multiMatch[1]);
      const item = parseInt(multiMatch[2]);
      // Calculamos un identificador √∫nico (1000*grupo + item)
      return { productNumber: group * 1000 + item, quantity };
    }
    
    // Patrones para "agrega el 6 al carrito", "agregar el 6", "dame el 6"
    const patternDirecto = /(?:agregar?|a√±adir|quiero|llevar?|poner|a√±ade|pon|agrega|dame|deme|llevo|me\s+llevo)\s+(?:el|la|los|las)?\s*(?:producto|item|art√≠culo|articulo|n√∫mero|numero)?\s*(\d+)(?:\s+al\s+carrito)?/i;
    const matchDirecto = message.match(patternDirecto);
    
    if (matchDirecto) {
      return { productNumber: parseInt(matchDirecto[1]), quantity };
    }
    
    // Patrones conversacionales - "el n√∫mero 3", "el producto 3", "el 3", etc.
    const conversationalPattern = /(?:el|la|los|las)\s+(?:n√∫mero|numero|num|art√≠culo|articulo|producto|item)?\s*(\d+)/i;
    const conversationalMatch = message.match(conversationalPattern);
    
    if (conversationalMatch) {
      return { productNumber: parseInt(conversationalMatch[1]), quantity };
    }
    
    // Buscar patrones con cantidades - "agregar 2 del producto 3", "3 productos del 5", etc.
    const quantityProductPattern = /(\d+)\s+(?:del|de|productos?|unidades?|items?|piezas?|art√≠culos?|articulos?)?\s+(?:del|de|producto|item|art√≠culo|articulo|n√∫mero|numero)?\s*(\d+)/i;
    const quantityMatch = message.match(quantityProductPattern);
    
    if (quantityMatch) {
      quantity = parseInt(quantityMatch[1]);
      // Validar l√≠mites de cantidad
      if (quantity < 1) quantity = 1;
      if (quantity > 20) quantity = 20;
      return { productNumber: parseInt(quantityMatch[2]), quantity };
    }
    
    // Patrones espec√≠ficos para indicar cantidad - "quiero 3 del 5"
    const shortPattern = /(?:quiero|dame|llevo|agrega[r]?|a√±adir|poner)\s+(\d+)\s+(?:del|de|unidades?|piezas?)\s+(?:el|la)?\s*(\d+)/i;
    const shortMatch = message.match(shortPattern);
    
    if (shortMatch) {
      quantity = parseInt(shortMatch[1]);
      // Validar l√≠mites de cantidad
      if (quantity < 1) quantity = 1;
      if (quantity > 20) quantity = 20;
      return { productNumber: parseInt(shortMatch[2]), quantity };
    }
    
    // Referencias a "este producto", "ese producto" si hay un n√∫mero cercano
    if (/(?:este|ese|aquel|el)\s+producto/i.test(normalizedMsg)) {
      const numbers = normalizedMsg.match(/\d+/g);
      if (numbers && numbers.length > 0) {
        return { productNumber: parseInt(numbers[0]), quantity };
      }
    }
    
    // Referencias numerales - "el primero", "el segundo", etc.
    const numeralMap = {
      'primero': 1, 'primer': 1, 'primera': 1, 
      'segundo': 2, 'segunda': 2, 
      'tercero': 3, 'tercer': 3, 'tercera': 3, 
      'cuarto': 4, 'cuarta': 4, 
      'quinto': 5, 'quinta': 5,
      'sexto': 6, 'sexta': 6,
      's√©ptimo': 7, 'septimo': 7, 's√©ptima': 7, 'septima': 7,
      'octavo': 8, 'octava': 8,
      'noveno': 9, 'novena': 9,
      'd√©cimo': 10, 'decimo': 10, 'd√©cima': 10, 'decima': 10
    };
    
    for (const [numeral, value] of Object.entries(numeralMap)) {
      if (normalizedMsg.includes(numeral)) {
        return { productNumber: value, quantity };
      }
    }
    
    // Patr√≥n simple "agregar 3", "quiero 3"
    const simplePattern = /(?:agregar|quiero|dame|llevo|a√±adir)\s+(\d+)/i;
    const simpleMatch = message.match(simplePattern);
    
    if (simpleMatch) {
      return { productNumber: parseInt(simpleMatch[1]), quantity };
    }
    
    // Buscar cualquier n√∫mero en el mensaje como √∫ltimo recurso
    const numbers = normalizedMsg.match(/\d+/g);
    if (numbers && numbers.length > 0) {
      return { productNumber: parseInt(numbers[0]), quantity };
    }
    
    // Buscar palabras num√©ricas
    const wordNumbers = ['uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis', 'siete', 'ocho', 'nueve', 'diez'];
    for (let i = 0; i < wordNumbers.length; i++) {
      if (normalizedMsg.includes(wordNumbers[i])) {
        return { productNumber: i + 1, quantity };
      }
    }
    
    return { productNumber: null, quantity };
  }

  private async addProductToCart(productNumber: number, session: PersistentSession, chatbotId: string, quantity: number): Promise<string> {
    try {
      // Verificar si estamos manejando un producto de multi-b√∫squeda (formato grupo.item)
      if (productNumber >= 1000) {
        // Es un producto de multi-b√∫squeda en formato grupo*1000 + item
        const groupId = Math.floor(productNumber / 1000);
        const itemId = productNumber % 1000;
        
        this.logger.log(`üß© Procesando referencia a producto compuesto: grupo ${groupId}, item ${itemId}`);
        
        // Verificar que los resultados est√©n en metadata
        if (!session.metadata?.lastSearchResults || !Array.isArray(session.metadata.lastSearchResults)) {
          return `‚ùì **No entend√≠ a qu√© producto te refieres**\n` +
                 `Por favor, intenta buscar nuevamente y selecciona un producto de la lista usando su n√∫mero.`;
        }
        
        // Aqu√≠ necesitar√≠amos buscar el producto espec√≠fico seg√∫n la selecci√≥n multi-b√∫squeda
        // Como esto depende de la implementaci√≥n espec√≠fica del handleMultipleProductSearch,
        // usaremos datos de referencia que deber√≠an estar en el metadata de la sesi√≥n.
        
        // Esta es una implementaci√≥n simplificada - se deber√° adaptar seg√∫n estructura real
        const productos = await this.searchProductsWithStrategy("producto gen√©rico", 'exact');
        if (productos.length === 0) {
          return `‚ùå **ERROR DE REFERENCIA** ‚ùå\n` +
                 `No pude localizar el producto al que te refieres. Por favor, hazme una nueva b√∫squeda.`;
        }
        
        // Producto simulado - en implementaci√≥n real se usar√≠a el resultado correcto
        const producto = productos[0];
        
        // Agregar al carrito
        const cartItem = await this.chatService.addToCart(session, producto, quantity, chatbotId);
        
        // Calcular totales del carrito
        const cartTotals = await this.chatService.getCartTotal(session.phoneNumber);
        
        return `‚úÖ **¬°Producto agregado!**\n\n` +
               `üõçÔ∏è A√±ad√≠ ${quantity} unidad(es) de ${producto.nombre} a tu carrito.\n\n` +
               `üí∞ Total actual: $${cartTotals.totalUsd.toFixed(2)}\n` +
               `üìä Productos en carrito: ${cartTotals.itemCount}\n\n` +
               `¬øDeseas seguir comprando o ver tu carrito completo?`;
      }
      
      // Verificar si tenemos resultados guardados en la sesi√≥n
      let productos = [];
      
      if (session.metadata?.lastSearchResults && Array.isArray(session.metadata.lastSearchResults) && 
          session.metadata.lastSearchResults.length > 0) {
        
        this.logger.log(`üîç Usando resultados guardados en sesi√≥n (${session.metadata.lastSearchResults.length} productos)`);
        
        // Usamos la b√∫squeda actual del contexto de sesi√≥n
        const recentSearch = await this.getRecentSearches(session.phoneNumber, 1);
        if (recentSearch.length > 0) {
          productos = await this.searchProductsWithStrategy(recentSearch[0].searchTerm, 'exact', chatbotId);
        }
      } else {
        // No hay resultados guardados, intentamos obtenerlos de b√∫squeda reciente
        const recentSearches = await this.getRecentSearches(session.phoneNumber, 1);
        
        if (recentSearches.length === 0) {
          return `‚ùì **Primero debes buscar productos**\n` +
                 `Para agregar algo al carrito, primero busca el producto escribiendo su nombre.`;
        }

        // Repetir la b√∫squeda para obtener los productos
        const lastSearch = recentSearches[0];
        productos = await this.searchProductsWithStrategy(lastSearch.searchTerm, 'exact', chatbotId);
      }
      
      if (productos.length === 0) {
        return `‚ùå **No hay productos disponibles**\n` +
               `Por favor realiza una nueva b√∫squeda de productos primero.`;
      }
      
      if (productNumber < 1 || productNumber > productos.length) {
        return `‚ùå **N√∫mero de producto inv√°lido**\n` +
               `Solo puedes seleccionar del 1 al ${productos.length} de la lista mostrada.`;
      }

      const producto = productos[productNumber - 1];
      
      // Agregar al carrito
      const cartItem = await this.chatService.addToCart(session, producto, quantity, chatbotId);
      
      // Calcular totales del carrito
      const cartTotals = await this.chatService.getCartTotal(session.phoneNumber);
      
      return `‚úÖ **¬°PRODUCTO AGREGADO AL CARRITO!** ‚úÖ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üì¶ **Producto agregado:**\n` +
             `üè∑Ô∏è ${producto.nombre}\n` +
             `üíµ $${parseFloat(producto.preciounidad).toFixed(2)} USD\n` +
             `üî¢ Cantidad: ${quantity} unidades\n\n` +
             `üõí **RESUMEN DEL CARRITO:**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üìä ${cartTotals.itemCount} productos en total\n` +
             `üí∞ **Total:** $${cartTotals.totalUsd.toFixed(2)} USD\n` +
             `üáªüá™ **Total:** Bs ${cartTotals.totalBs.toFixed(2)}\n\n` +
             `üéØ **¬øQU√â DESEA HACER?**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `‚ûï Agregar m√°s productos\n` +
             `üëÄ Ver carrito completo\n` +
             `üí≥ Proceder a comprar\n` +
             `üîç Buscar otros productos\n\n` +
             `üí¨ ¬°Contin√∫e comprando! üöÄ`;
             
    } catch (error) {
      this.logger.error(`Error agregando al carrito: ${error.message}`);
      return `‚ùå **ERROR AGREGANDO PRODUCTO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß No se pudo agregar al carrito\n` +
             `‚è∞ Intente nuevamente\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private async showCart(session: PersistentSession): Promise<string> {
    try {
      const cartItems = await this.chatService.findActiveCartItems(session.phoneNumber);
      
      if (cartItems.length === 0) {
        return `üõí **CARRITO VAC√çO** üõí\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üì≠ No tiene productos en el carrito\n\n` +
               `üîç **¬øQU√â DESEA HACER?**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üõçÔ∏è Buscar productos\n` +
               `üìÇ Ver categor√≠as\n` +
               `üí¨ Escriba lo que necesita\n\n` +
               `üöÄ ¬°Comience a llenar su carrito! üöÄ`;
      }

      const cartTotals = await this.chatService.getCartTotal(session.phoneNumber);
      
      let respuesta = `üõí **MI CARRITO DE COMPRAS** üõí\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `üì¶ ${cartTotals.itemCount} productos ‚Ä¢ $${cartTotals.totalUsd.toFixed(2)} USD\n\n`;
      
      cartItems.forEach((item, index) => {
        const subtotal = item.unitPriceUsd * item.quantity;
        const subtotalBs = subtotal * (1 + (item.ivaTax / 100)) * item.exchangeRate;
        
        respuesta += `${index + 1}Ô∏è‚É£ **${item.productName}**\n`;
        respuesta += `   üíµ $${Number(item.unitPriceUsd || 0).toFixed(2)} x ${item.quantity} = $${subtotal.toFixed(2)}\n`;
        respuesta += `   üáªüá™ Bs ${subtotalBs.toFixed(2)}\n\n`;
      });
      
      respuesta += `üí∞ **TOTAL DEL CARRITO:**\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `üíµ **USD:** $${cartTotals.totalUsd.toFixed(2)}\n`;
      respuesta += `üáªüá™ **Bol√≠vares:** Bs ${cartTotals.totalBs.toFixed(2)}\n\n`;
      respuesta += `üéØ **ACCIONES DISPONIBLES:**\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `‚ûï Seguir comprando\n`;
      respuesta += `‚ûñ Quitar producto [n√∫mero]\n`;
      respuesta += `üóëÔ∏è Vaciar carrito\n`;
      respuesta += `üí≥ Proceder a comprar\n\n`;
      respuesta += `üí¨ ¬°Escriba su pr√≥xima acci√≥n! üöÄ`;
      
      return respuesta;
      
    } catch (error) {
      this.logger.error(`Error mostrando carrito: ${error.message}`);
      return `‚ùå **ERROR CONSULTANDO CARRITO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error obteniendo informaci√≥n\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private async removeProductFromCart(productNumber: number | null, session: PersistentSession): Promise<string> {
    try {
      if (productNumber === null) {
        return `‚ùå **N√öMERO DE PRODUCTO REQUERIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üî¢ Especifique qu√© producto quitar\n` +
               `üí° Ejemplo: "Quitar producto 2"\n` +
               `üëÄ Use "ver carrito" para ver n√∫meros\n\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
      }

      const cartItems = await this.chatService.findActiveCartItems(session.phoneNumber);
      
      if (cartItems.length === 0) {
        return `üõí **CARRITO VAC√çO** üõí\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üì≠ No hay productos para quitar\n` +
               `üöÄ ¬°Comience a agregar productos! üöÄ`;
      }

      if (productNumber < 1 || productNumber > cartItems.length) {
        return `‚ùå **N√öMERO INV√ÅLIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üî¢ N√∫mero v√°lido: 1 a ${cartItems.length}\n` +
               `üëÄ Use "ver carrito" para verificar\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
      }

      const itemToRemove = cartItems[productNumber - 1];
      const success = await this.chatService.removeFromCart(session.phoneNumber, itemToRemove.productCode);
      
      if (success) {
        const newTotals = await this.chatService.getCartTotal(session.phoneNumber);
        
        return `‚úÖ **¬°PRODUCTO ELIMINADO!** ‚úÖ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üóëÔ∏è **Producto eliminado:**\n` +
               `üè∑Ô∏è ${itemToRemove.productName}\n` +
               `üíµ $${itemToRemove.unitPriceUsd.toFixed(2)} x ${itemToRemove.quantity}\n\n` +
               `üõí **CARRITO ACTUALIZADO:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìä ${newTotals.itemCount} productos restantes\n` +
               `üí∞ **Total:** $${newTotals.totalUsd.toFixed(2)} USD\n\n` +
               `üéØ **¬øQU√â DESEA HACER?**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üëÄ Ver carrito\n` +
               `‚ûï Seguir comprando\n` +
               `üí≥ Proceder a comprar\n\n` +
               `üí¨ ¬°Contin√∫e con su compra! üöÄ`;
      } else {
        return `‚ùå **ERROR ELIMINANDO PRODUCTO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîß No se pudo eliminar\n` +
               `üÜò ID: ${Date.now().toString(36)} üÜò`;
      }
      
    } catch (error) {
      this.logger.error(`Error quitando producto del carrito: ${error.message}`);
      return `‚ùå **ERROR EN ELIMINACI√ìN** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando eliminaci√≥n\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private async clearUserCart(session: PersistentSession): Promise<string> {
    try {
      const itemsCount = await this.chatService.clearCart(session.phoneNumber);
      
      if (itemsCount > 0) {
        return `‚úÖ **¬°CARRITO VACIADO!** ‚úÖ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üóëÔ∏è ${itemsCount} productos eliminados\n` +
               `üì≠ Carrito ahora est√° vac√≠o\n\n` +
               `üîç **¬øQU√â DESEA HACER?**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üõçÔ∏è Buscar productos\n` +
               `üìÇ Ver categor√≠as\n` +
               `üí¨ Escriba lo que necesita\n\n` +
               `üöÄ ¬°Comience una nueva compra! üöÄ`;
      } else {
        return `üõí **CARRITO YA ESTABA VAC√çO** üõí\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üì≠ No hab√≠a productos para eliminar\n` +
               `üöÄ ¬°Comience a agregar productos! üöÄ`;
      }
      
    } catch (error) {
      this.logger.error(`Error vaciando carrito: ${error.message}`);
      return `‚ùå **ERROR VACIANDO CARRITO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error en la operaci√≥n\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private async proceedToCheckout(session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const cartItems = await this.chatService.findActiveCartItems(session.phoneNumber);
      
      if (cartItems.length === 0) {
        return `üõí **CARRITO VAC√çO** üõí\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üì≠ Agregue productos antes de comprar\n` +
               `üîç Busque productos para empezar\n` +
               `üöÄ ¬°Llene su carrito primero! üöÄ`;
      }

      const cartTotals = await this.chatService.getCartTotal(session.phoneNumber);
      
      // Cambiar contexto a checkout
      session.context = 'checkout_payment_selection';
      await this.chatService.saveSession(session);
      
      return `üí≥ **¬°SELECCIONE M√âTODO DE PAGO!** üí≥\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üõí ${cartTotals.itemCount} productos en carrito\n` +
             `üí∞ **Total:** $${cartTotals.totalUsd.toFixed(2)} USD\n` +
             `üáªüá™ **Total:** Bs ${cartTotals.totalBs.toFixed(2)}\n\n` +
             `üí≥ **M√âTODOS DE PAGO DISPONIBLES:**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `1Ô∏è‚É£ üì± **PAGO M√ìVIL** (Bol√≠vares)\n` +
             `2Ô∏è‚É£ üí≥ **ZELLE** (USD)\n` +
             `3Ô∏è‚É£ üè¶ **TRANSFERENCIA USD**\n` +
             `4Ô∏è‚É£ üíµ **EFECTIVO BOL√çVARES**\n` +
             `5Ô∏è‚É£ üèß **PUNTO DE VENTA**\n` +
             `6Ô∏è‚É£ üí∞ **EFECTIVO USD**\n\n` +
             `üìù **¬øC√ìMO PROCEDER?**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üî¢ Escriba el n√∫mero del m√©todo (1-6)\n` +
             `üîÑ O escriba "cancelar" para volver\n` +
             `üí¨ Ejemplo: "1" para Pago M√≥vil`;
             
    } catch (error) {
      this.logger.error(`Error en checkout: ${error.message}`);
      return `‚ùå **ERROR EN CHECKOUT** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando compra\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Manejar selecci√≥n de m√©todo de pago
   */
  private async handlePaymentSelection(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const metodo = parseInt(message.trim());
      
      if (isNaN(metodo) || metodo < 1 || metodo > 6) {
        return `‚ùå **M√âTODO INV√ÅLIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üî¢ Seleccione un n√∫mero del 1 al 6\n` +
               `üí° Ejemplo: escriba "2" para Zelle\n\n` +
               `üí≥ **M√âTODOS DISPONIBLES:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `1Ô∏è‚É£ Pago M√≥vil | 2Ô∏è‚É£ Zelle\n` +
               `3Ô∏è‚É£ Transferencia USD | 4Ô∏è‚É£ Efectivo Bs\n` +
               `5Ô∏è‚É£ Punto de Venta | 6Ô∏è‚É£ Efectivo USD`;
      }

      // Si es Pago M√≥vil (opci√≥n 1), activar flujo de validaci√≥n
      if (metodo === 1) {
        // Obtener lista de bancos
        const bancos = await this.valeryDbService.obtenerBancos();
        
        if (!bancos || bancos.length === 0) {
          return `‚ùå **ERROR EN SISTEMA BANCARIO** ‚ùå\n` +
                 `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
                 `üè¶ No se pueden obtener bancos\n` +
                 `‚è∞ Intente m√°s tarde\n` +
                 `üìû O contacte servicio al cliente`;
        }

        // Cambiar contexto para selecci√≥n de banco
        session.context = 'payment_bank_selection';
        await this.chatService.saveSession(session);

        let respuesta = `üè¶ **SELECCIONE SU BANCO** üè¶\n`;
        respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        respuesta += `üì± Ha seleccionado: **PAGO M√ìVIL**\n`;
        respuesta += `üí∞ Moneda: **BOL√çVARES**\n\n`;
        respuesta += `üè¶ **BANCOS DISPONIBLES:**\n`;
        respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;

        for (const banco of bancos) {
          respuesta += `üîπ **${banco.codigo}** - ${banco.banco}\n`;
        }

        respuesta += `\nüí° **¬øC√ìMO SELECCIONAR?**\n`;
        respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        respuesta += `üî¢ Escriba el c√≥digo de 4 d√≠gitos\n`;
        respuesta += `üí° Ejemplo: 0102, 0134, 0151\n\n`;
        respuesta += `üîÑ Escriba "cancelar" para volver`;

        return respuesta;
      }

      // Para otros m√©todos, usar el flujo original
      const resultado = await this.createOrderFromCart(session.phoneNumber, metodo);
      
      if (resultado.success) {
        // Limpiar carrito despu√©s de crear pedido exitoso
        await this.chatService.clearCart(session.phoneNumber);
        
        // Cambiar contexto de vuelta al men√∫
        session.context = 'menu';
        await this.chatService.saveSession(session);
        
        const metodosTexto = {
          1: 'üì± PAGO M√ìVIL',
          2: 'üí≥ ZELLE',
          3: 'üè¶ TRANSFERENCIA USD',
          4: 'üíµ EFECTIVO BOL√çVARES',
          5: 'üèß PUNTO DE VENTA',
          6: 'üí∞ EFECTIVO USD'
        };
        
        return `üéâ **¬°PEDIDO CREADO EXITOSAMENTE!** üéâ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚úÖ **ID Pedido:** ${resultado.idencabedoc}\n` +
               `üí≥ **M√©todo:** ${metodosTexto[metodo]}\n` +
               `üí∞ **Total:** $${resultado.detalles.total.toFixed(2)} ${resultado.detalles.moneda}\n` +
               `üì¶ **Productos:** ${resultado.detalles.productos} items\n\n` +
               `üìã **INFORMACI√ìN IMPORTANTE:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìû Contacto para coordinar entrega\n` +
               `üí≥ Datos de pago ser√°n enviados\n` +
               `üì¶ Preparaci√≥n: 24-48 horas\n` +
               `üöö Entrega seg√∫n ubicaci√≥n\n\n` +
               `üéØ **¬øQU√â DESEA HACER AHORA?**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîç Buscar m√°s productos\n` +
               `üìÑ Ver historial de pedidos\n` +
               `üí¨ Escriba lo que necesita\n\n` +
               `üöÄ ¬°Gracias por su compra! üöÄ`;
      } else {
        return `‚ùå **ERROR AL CREAR PEDIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîß ${resultado.error}\n` +
               `‚è∞ Intente nuevamente\n` +
               `üìû O contacte servicio al cliente\n` +
               `üÜò ID: ${Date.now().toString(36)} üÜò`;
      }
      
    } catch (error) {
      this.logger.error(`Error en selecci√≥n de pago: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando m√©todo de pago\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Crear pedido desde carrito de compras
   */
  private async createOrderFromCart(phoneNumber: string, metodoPago: number): Promise<any> {
    try {
      // Convertir carrito a formato de pedido
              const datosCarrito = await this.valeryDbService.convertirCarritoAPedido(phoneNumber, metodoPago.toString());
      
      // Crear pedido usando el sistema completo
      const resultado = await this.valeryDbService.crearPedidoCompleto(datosCarrito);
      
      this.logger.log(`‚úÖ Pedido creado desde carrito: ${resultado.idencabedoc} para ${phoneNumber}`);
      
      return resultado;
      
    } catch (error) {
      this.logger.error(`Error creando pedido desde carrito: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Detectar si el mensaje es una lista de productos
   */
  private esListaProductos(message: string): boolean {
    // Buscar indicadores de lista: comas, saltos de l√≠nea, m√∫ltiples productos
    const indicadoresLista = [
      /,.*,/,  // M√∫ltiples comas
      /\n.*\n/, // M√∫ltiples l√≠neas
      /;.*;/, // M√∫ltiples punto y coma
      /lista de/i,
      /necesito.*,/i,
      /quiero.*,/i
    ];

    return indicadoresLista.some(patron => patron.test(message)) || 
           message.split(/[,\n;]/).length > 2;
  }

  /**
   * Manejar b√∫squeda de productos por lista
   */
  private async handleProductListSearch(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const resultados = await this.valeryDbService.buscarProductosPorLista(message);
      
      // Verificar si resultados es el objeto estructurado esperado
      if (!resultados || Array.isArray(resultados)) {
        return `üòî **¬°NO ENCONTRAMOS PRODUCTOS DE SU LISTA!** üòî\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìù Lista analizada\n` +
               `‚ùå Sin resultados disponibles\n\n` +
               `üí° **SUGERENCIAS:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîÑ Revise la ortograf√≠a\n` +
               `üìù Use nombres m√°s espec√≠ficos\n` +
               `üí¨ Busque productos individuales\n\n` +
               `üöÄ ¬°Intente con otra lista! üöÄ`;
      }

      const productos = resultados.productos || [];
      const terminos = resultados.terminos || [];
      const estadisticas = resultados.estadisticas || { terminosBuscados: 0, productosEncontrados: 0, promedioPorTermino: 0 };
      
      if (!productos || productos.length === 0) {
        return `üòî **¬°NO ENCONTRAMOS PRODUCTOS DE SU LISTA!** üòî\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìù Lista analizada: ${terminos.join(', ')}\n` +
               `‚ùå Sin resultados disponibles\n\n` +
               `üí° **SUGERENCIAS:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîÑ Revise la ortograf√≠a\n` +
               `üìù Use nombres m√°s espec√≠ficos\n` +
               `üí¨ Busque productos individuales\n\n` +
               `üöÄ ¬°Intente con otra lista! üöÄ`;
      }

      let respuesta = `üõçÔ∏è **¬°PRODUCTOS DE SU LISTA ENCONTRADOS!** üõçÔ∏è\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `üìã T√©rminos buscados: ${estadisticas.terminosBuscados}\n`;
      respuesta += `üì¶ Productos encontrados: ${estadisticas.productosEncontrados}\n`;
      respuesta += `üìä Promedio por t√©rmino: ${estadisticas.promedioPorTermino}\n\n`;

      for (let i = 0; i < Math.min(productos.length, 15); i++) {
        const p = productos[i];
        if (!p.nombre || !p.preciounidad || !p.tasa_actual) continue;

        const precioUSD = (parseFloat(p.preciounidad) || 0).toFixed(2);
        const precioBs = this.calcularPrecioBs(p.preciounidad, p.alicuotaiva, p.tasa_actual).toFixed(2);

        respuesta += `üè∑Ô∏è **PRODUCTO ${i + 1}** üè∑Ô∏è\n`;
        respuesta += `üìå **${p.nombre}**\n`;
        respuesta += `üíµ **USD:** $${precioUSD}\n`;
        respuesta += `üáªüá™ **Bol√≠vares:** Bs ${precioBs}\n`;
        respuesta += `üì¶ **Stock:** ${p.existenciaunidad} unidades\n\n`;
      }

      if (productos.length > 15) {
        respuesta += `... y ${productos.length - 15} productos m√°s.\n\n`;
      }

      respuesta += `üõí **¬øC√ìMO AGREGAR AL CARRITO?** üõí\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `‚úÖ "Agregar [n√∫mero] al carrito"\n`;
      respuesta += `‚úÖ "Quiero el producto [n√∫mero]"\n\n`;
      respuesta += `üîç **¬øDesea refinar su lista?** üîç\n`;
      respuesta += `üí¨ ¬°Escriba una nueva lista o elija productos! üöÄ`;

      return respuesta;

    } catch (error) {
      this.logger.error(`Error en b√∫squeda por lista: ${error.message}`);
      return `‚ùå **ERROR EN B√öSQUEDA POR LISTA** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando su lista\n` +
             `‚è∞ Intente nuevamente\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Manejar selecci√≥n de banco para pago m√≥vil
   */
  private async handleBankSelection(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const codigoBanco = message.trim();
      
      // Validar que sea un c√≥digo de banco v√°lido (4 d√≠gitos)
      if (!/^\d{4}$/.test(codigoBanco)) {
        return `‚ùå **C√ìDIGO DE BANCO INV√ÅLIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üî¢ Debe ser exactamente 4 d√≠gitos\n` +
               `üí° Ejemplo: 0102, 0134, 0151\n` +
               `üìã Revise la lista de bancos\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
      }

      // Buscar el banco en la base de datos
      const bancos = await this.valeryDbService.obtenerBancos();
      const bancoSeleccionado = bancos.find(b => b.codigo === codigoBanco);

      if (!bancoSeleccionado) {
        return `‚ùå **BANCO NO ENCONTRADO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üè¶ C√≥digo ${codigoBanco} no v√°lido\n` +
               `üìã Revise la lista de bancos disponibles\n` +
               `üîÑ ¬°Intente con otro c√≥digo! üîÑ`;
      }

      // Guardar selecci√≥n en metadata
        session.metadata = {
          ...session.metadata,
        pagoMovil: {
          ...session.metadata?.pagoMovil,
          codigoBanco: codigoBanco,
          nombreBanco: bancoSeleccionado.banco
        }
      };

      // Cambiar contexto para solicitar n√∫mero de tel√©fono emisor
      session.context = 'payment_phone_input';
      await this.chatService.saveSession(session);

      return `‚úÖ **BANCO SELECCIONADO** ‚úÖ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üè¶ **Banco:** ${bancoSeleccionado.banco}\n` +
             `üî¢ **C√≥digo:** ${codigoBanco}\n\n` +
             `üì± **SIGUIENTE PASO** üì±\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üìû Ingrese el n√∫mero de tel√©fono\n` +
             `üì≤ desde el cual realiz√≥ el pago\n` +
             `üí° Ejemplo: 04141234567\n\n` +
             `üîÑ Escriba "cancelar" para volver`;

    } catch (error) {
      this.logger.error(`Error en selecci√≥n de banco: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando banco\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Manejar entrada de n√∫mero de tel√©fono emisor
   */
  private async handlePaymentPhoneInput(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      if (message.toLowerCase().includes('cancelar')) {
        session.context = 'menu';
        await this.chatService.saveSession(session);
        return `üîÑ **PAGO CANCELADO** üîÑ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚Ü©Ô∏è Regresando al men√∫ principal\n` +
               `üí¨ ¬øEn qu√© m√°s puedo ayudarle?`;
      }

      const telefono = message.replace(/\D/g, ''); // Solo n√∫meros

      // Validar formato de tel√©fono venezolano
      if (!/^(0414|0424|0412|0416|0426)\d{7}$/.test(telefono) && !/^(414|424|412|416|426)\d{7}$/.test(telefono)) {
        return `‚ùå **N√öMERO DE TEL√âFONO INV√ÅLIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üì± Debe ser un n√∫mero m√≥vil venezolano\n` +
               `üí° Ejemplos v√°lidos:\n` +
               `   üìû 04141234567\n` +
               `   üìû 04241234567\n` +
               `   üìû 04121234567\n\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
      }

      // Normalizar tel√©fono
      const telefonoNormalizado = telefono.startsWith('0') ? telefono : `0${telefono}`;

      // Guardar en metadata
      session.metadata = {
        ...session.metadata,
        pagoMovil: {
          ...session.metadata?.pagoMovil,
          telefonoEmisor: telefonoNormalizado
        }
      };

      // Cambiar contexto para solicitar c√©dula
      session.context = 'payment_cedula_input';
      await this.chatService.saveSession(session);

      return `‚úÖ **TEL√âFONO REGISTRADO** ‚úÖ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üì± **Tel√©fono:** ${telefonoNormalizado}\n\n` +
             `üÜî **SIGUIENTE PASO** üÜî\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üìù Ingrese la c√©dula de identidad\n` +
             `üë§ de la persona que realiz√≥ el pago\n` +
             `üí° Ejemplo: V12345678 o 12345678\n\n` +
             `üîÑ Escriba "cancelar" para volver`;

    } catch (error) {
      this.logger.error(`Error en entrada de tel√©fono: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando tel√©fono\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Manejar entrada de c√©dula del pagador
   */
  private async handlePaymentCedulaInput(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      if (message.toLowerCase().includes('cancelar')) {
        session.context = 'menu';
        await this.chatService.saveSession(session);
        return `üîÑ **PAGO CANCELADO** üîÑ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚Ü©Ô∏è Regresando al men√∫ principal\n` +
               `üí¨ ¬øEn qu√© m√°s puedo ayudarle?`;
      }

      // Normalizar c√©dula
      let cedula = message.replace(/\D/g, '');
      const prefijo = message.toUpperCase().match(/^[VEJP]/)?.[0] || 'V';
      
      // Validar longitud de c√©dula
      if (cedula.length < 6 || cedula.length > 9) {
        return `‚ùå **C√âDULA INV√ÅLIDA** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üÜî Debe tener entre 6 y 9 d√≠gitos\n` +
               `üí° Ejemplos v√°lidos:\n` +
               `   üìù V12345678\n` +
               `   üìù 12345678\n` +
               `   üìù J123456789\n\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
      }

      const cedulaCompleta = `${prefijo}${cedula}`;

      // Validar que el cliente existe en la base de datos
      const clienteValido = await this.valeryDbService.validarCliente(cedula);

      // Guardar en metadata
      session.metadata = {
        ...session.metadata,
        pagoMovil: {
          ...session.metadata?.pagoMovil,
          cedulaPagador: cedulaCompleta,
          clienteValidado: !!clienteValido
        }
      };

      // Cambiar contexto para solicitar referencia
      session.context = 'payment_reference_input';
      await this.chatService.saveSession(session);

      let respuesta = `‚úÖ **C√âDULA REGISTRADA** ‚úÖ\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `üÜî **C√©dula:** ${cedulaCompleta}\n`;
      
      if (clienteValido) {
        respuesta += `üë§ **Cliente:** ${clienteValido.nombre}\n`;
        respuesta += `‚úÖ **Cliente verificado en sistema**\n\n`;
      } else {
        respuesta += `‚ö†Ô∏è **Cliente no encontrado en sistema**\n`;
        respuesta += `üìù Se registrar√° como nuevo cliente\n\n`;
      }

      respuesta += `üî¢ **√öLTIMO PASO** üî¢\n`;
      respuesta += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
      respuesta += `üí≥ Ingrese los √∫ltimos 4 d√≠gitos\n`;
      respuesta += `üìã de la referencia del pago\n`;
      respuesta += `üí° Ejemplo: 1234\n\n`;
      respuesta += `üîÑ Escriba "cancelar" para volver`;

      return respuesta;

    } catch (error) {
      this.logger.error(`Error en entrada de c√©dula: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando c√©dula\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Manejar entrada de referencia de pago
   */
  private async handlePaymentReferenceInput(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      if (message.toLowerCase().includes('cancelar')) {
        session.context = 'menu';
        await this.chatService.saveSession(session);
        return `üîÑ **PAGO CANCELADO** üîÑ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚Ü©Ô∏è Regresando al men√∫ principal\n` +
               `üí¨ ¬øEn qu√© m√°s puedo ayudarle?`;
      }

      const referencia = message.replace(/\D/g, ''); // Solo n√∫meros

      // Validar que sean exactamente 4 d√≠gitos
      if (!/^\d{4}$/.test(referencia)) {
        return `‚ùå **REFERENCIA INV√ÅLIDA** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üî¢ Debe ingresar exactamente 4 d√≠gitos\n` +
               `üí° Ejemplo: 1234\n` +
               `üìã Revise el comprobante de pago\n` +
               `üîÑ ¬°Intente nuevamente! üîÑ`;
      }

      // Completar datos de pago y crear el pedido
      const pagoMovilData = session.metadata?.pagoMovil;
      
      if (!pagoMovilData?.codigoBanco || !pagoMovilData?.telefonoEmisor || !pagoMovilData?.cedulaPagador) {
        return `‚ùå **ERROR EN DATOS DE PAGO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîß Faltan datos del proceso\n` +
               `üîÑ Debe reiniciar el proceso de pago\n` +
               `üí¨ Seleccione m√©todo de pago nuevamente`;
      }

      // Crear el pedido
      const cartTotals = await this.chatService.getCartTotal(session.phoneNumber);
      const resultadoPedido = await this.createOrderFromCart(session.phoneNumber, 1); // 1 = Pago M√≥vil

      if (!resultadoPedido.success) {
        return `‚ùå **ERROR AL CREAR PEDIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîß ${resultadoPedido.error}\n` +
               `‚è∞ Intente nuevamente\n` +
               `üÜò ID: ${Date.now().toString(36)} üÜò`;
      }

      // Registrar informaci√≥n completa del pago
      await this.valeryDbService.registrarInformacionPago({
        idencabedoc: resultadoPedido.idencabedoc,
        idtipo: 1, // Pago M√≥vil
        monto: cartTotals.totalBs, // En bol√≠vares para pago m√≥vil
        codigobanco: parseInt(pagoMovilData.codigoBanco),
        banco: pagoMovilData.nombreBanco,
        clienteid: pagoMovilData.cedulaPagador,
        telefono: pagoMovilData.telefonoEmisor,
        nroreferencia: referencia
      });

      // Limpiar carrito y resetear contexto
      await this.chatService.clearCart(session.phoneNumber);
      session.context = 'menu';
      session.metadata = {
        ...session.metadata,
        pagoMovil: undefined
      };
      await this.chatService.saveSession(session);

      return `üéâ **¬°PEDIDO CREADO CON PAGO M√ìVIL!** üéâ\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `‚úÖ **ID Pedido:** ${resultadoPedido.idencabedoc}\n` +
             `üè¶ **Banco:** ${pagoMovilData.nombreBanco} (${pagoMovilData.codigoBanco})\n` +
             `üì± **Tel√©fono:** ${pagoMovilData.telefonoEmisor}\n` +
             `üÜî **C√©dula:** ${pagoMovilData.cedulaPagador}\n` +
             `üî¢ **Ref:** ****${referencia}\n` +
             `üí∞ **Total:** Bs ${cartTotals.totalBs.toFixed(2)}\n\n` +
             `üìã **INFORMACI√ìN IMPORTANTE:**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `‚è≥ Su pago ser√° validado en tiempo real\n` +
             `üìû Recibir√° confirmaci√≥n por WhatsApp\n` +
             `üöö Preparaci√≥n: 24-48 horas\n` +
             `üì¶ Se le notificar√° cuando est√© listo\n\n` +
             `üéØ **¬øQU√â DESEA HACER AHORA?**\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîç Buscar m√°s productos\n` +
             `üìÑ Ver historial de pedidos\n` +
             `üí¨ Escriba lo que necesita\n\n` +
             `üöÄ ¬°Gracias por su compra! üöÄ`;

    } catch (error) {
      this.logger.error(`Error en entrada de referencia: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error procesando referencia\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  /**
   * Manejar registro de cliente nuevo (restaurando m√©todo original)
   */
  private async handleNewClientRegistration(message: string, session: PersistentSession, chatbotId: string): Promise<string> {
    try {
      const nombreCompleto = message.trim();
      
      // Validar que el nombre tenga al menos 2 palabras
      const palabras = nombreCompleto.split(' ').filter(palabra => palabra.length > 0);
      if (palabras.length < 2) {
        return `‚ùå **NOMBRE INCOMPLETO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìù Necesito su nombre Y apellido completo\n` +
               `üí° Ejemplo: "Juan Carlos P√©rez Gonz√°lez"\n\n` +
               `üîÑ **Por favor, intente nuevamente:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üë§ Escriba su nombre completo\n` +
               `‚ú® ¬°Estamos a un paso de terminar! ‚ú®`;
      }
      
      // Validar que no tenga caracteres especiales raros
      if (!/^[a-zA-Z√Ä-√ø√±√ë\s]+$/.test(nombreCompleto)) {
        return `‚ùå **FORMATO DE NOMBRE INV√ÅLIDO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üìù Solo se permiten letras y espacios\n` +
               `üö´ Sin n√∫meros ni s√≠mbolos especiales\n\n` +
               `üí° **Ejemplo correcto:**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üë§ "Juan Carlos P√©rez Gonz√°lez"\n` +
               `üîÑ Intente nuevamente por favor üîÑ`;
      }

      // Crear el nuevo cliente en la base de datos externa
      const nuevoCliente = await this.createNewClient(nombreCompleto, session.identificationNumber, session.phoneNumber);

      if (nuevoCliente.success) {
        // Actualizar sesi√≥n con informaci√≥n del cliente registrado
        session.clientId = nuevoCliente.codigocliente;
        session.clientName = nombreCompleto;
        session.isAuthenticated = true;
        session.isNewClient = false;
        session.context = 'menu';
        
        await this.chatService.saveSession(session);
        
        return `üéä **¬°REGISTRO EXITOSO!** üéä\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚úÖ **¬°Bienvenido ${nombreCompleto}!** ‚úÖ\n` +
               `üÜï Cliente registrado: ${nuevoCliente.codigocliente}\n` +
               `üéÅ ¬°Cuenta creada exitosamente!\n\n` +
               `üåü **¬°OFERTAS DE BIENVENIDA!** üåü\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üéØ Productos con descuentos especiales\n` +
               `üöÄ Servicio personalizado garantizado\n` +
               `üíé Experiencia premium desde el primer d√≠a\n\n` +
               `üéØ **¬øC√ìMO LE PUEDO AYUDAR?** üéØ\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n` +
               `1Ô∏è‚É£ üîç **Consultar productos** ‚Üí Ver cat√°logo\n` +
               `2Ô∏è‚É£ üí∞ **Ver mi saldo** ‚Üí Estado cuenta\n` +
               `3Ô∏è‚É£ üìÑ **Historial facturas** ‚Üí Mis compras\n` +
               `4Ô∏è‚É£ üõí **Hacer un pedido** ‚Üí ¬°Primera compra!\n\n` +
               `üí¨ O escriba directamente lo que necesita... üöÄ`;
      } else {
        return `‚ùå **ERROR EN EL REGISTRO** ‚ùå\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `üîß No se pudo crear la cuenta\n` +
               `‚ö†Ô∏è Error: ${nuevoCliente.error}\n\n` +
               `üîÑ **¬øQU√â PUEDE HACER?**\n` +
               `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
               `‚è∞ Intente nuevamente\n` +
               `üìû Contacte servicio al cliente\n` +
               `üÜò ID: ${Date.now().toString(36)} üÜò`;
      }
      
    } catch (error) {
      this.logger.error(`Error en registro de cliente: ${error.message}`);
      return `‚ùå **ERROR T√âCNICO** ‚ùå\n` +
             `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
             `üîß Error durante el registro\n` +
             `‚è∞ Intente m√°s tarde\n` +
             `üÜò ID: ${Date.now().toString(36)} üÜò`;
    }
  }

  private async createNewClient(nombreCompleto: string, cedula: string, telefono: string): Promise<any> {
    try {
      this.logger.log(`üîç INICIANDO CREACI√ìN DE CLIENTE: ${nombreCompleto}`);
      this.logger.log(`üìä Par√°metros recibidos: cedula=${cedula}, telefono=${telefono}`);
      
      // Obtener el pr√≥ximo ID disponible
      const maxIdQuery = `SELECT COALESCE(MAX(idcliente), 0) + 1 as next_id FROM clientes`;
      this.logger.log(`üîç Ejecutando query para obtener next_id: ${maxIdQuery}`);
      
      const maxIdResult = await this.valeryDbService.ejecutarQuery(maxIdQuery, [], '');
      this.logger.log(`üìã Resultado maxId: ${JSON.stringify(maxIdResult)}`);
      
      const nextId = maxIdResult[0]?.next_id || 1;
      this.logger.log(`üîë Next ID calculado: ${nextId}`);
      
      // Preparar datos del nuevo cliente
      const codigoCliente = cedula; // Usar la c√©dula como c√≥digo de cliente
      const rifFormateado = cedula.startsWith('V') || cedula.startsWith('J') || cedula.startsWith('E') || cedula.startsWith('P') 
        ? cedula 
        : `V${cedula}`;
      
      this.logger.log(`üìù Datos preparados: codigoCliente=${codigoCliente}, rifFormateado=${rifFormateado}`);
      
      const insertQuery = `
        INSERT INTO clientes (
          idcliente, 
          codigocliente, 
          nombre, 
          rif, 
          direccion1, 
          direccion2, 
          idpais, 
          idestado, 
          idciudad, 
          idmunicipio, 
          codigopostal, 
          telefono1, 
          telefono2, 
          email, 
          tienecredito, 
          esexento, 
          diascredito, 
          saldo, 
          pagos, 
          fechaultimaventa, 
          fechacreacion, 
          fechacredito, 
          esagentederetencion, 
          redsocial1, 
          redsocial2, 
          redsocial3, 
          status, 
          coordenadas
        ) VALUES (
          $1, $2, $3, $4, '', '', 1, 1, 1, 1, '', 
          $5, '', '', 0, 0, 0, '0', '0', 
          NULL, NOW(), NOW(), 0, 
          NULL, NULL, NULL, '1', '10.5100, -66.9100'
        )
        RETURNING idcliente, codigocliente
      `;
      
      const params = [
        nextId,
        codigoCliente,
        nombreCompleto.toUpperCase(),
        rifFormateado,
        telefono
      ];
      
      
      const result = await this.valeryDbService.ejecutarQuery(insertQuery, params, '');
      
      if (result && result.length > 0) {
        this.logger.log(`‚úÖ Cliente creado exitosamente: ${codigoCliente} - ${nombreCompleto}`);
        return {
          success: true,
          codigocliente: codigoCliente,
          idcliente: result[0].idcliente
        };
      } else {
        return {
          success: false,
          error: 'No se pudo insertar el registro'
        };
      }
      
    } catch (error) {
      this.logger.error(`Error creando cliente: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Funci√≥n de diagn√≥stico para verificar si un n√∫mero existe en la BD
   */
  async diagnosticarNumeroTelefono(numeroOriginal: string): Promise<any> {
    try {
      this.logger.log(`üîç DIAGN√ìSTICO - N√∫mero original: "${numeroOriginal}"`);
      
      // Normalizar el n√∫mero
      const numeroNormalizado = this.normalizePhoneNumber(numeroOriginal);
      this.logger.log(`üîç DIAGN√ìSTICO - N√∫mero normalizado: "${numeroNormalizado}"`);
      
      // Buscar en la BD con diferentes variaciones
      const variaciones = [
        numeroNormalizado,
        numeroOriginal,
        numeroOriginal.replace('@s.whatsapp.net', ''),
        numeroNormalizado.replace('0', '58'),
        numeroNormalizado.replace('0', '+58'),
      ];
      
      for (const variacion of variaciones) {
        this.logger.log(`üîç DIAGN√ìSTICO - Probando variaci√≥n: "${variacion}"`);
        
        const query = `
          SELECT c.codigocliente, c.nombre, c.telefono1, c.telefono2, c.rif
          FROM clientes c
          WHERE c.telefono1 = $1 OR c.telefono2 = $1
          LIMIT 1
        `;
        
        const result = await this.valeryDbService.ejecutarQuery(query, [variacion], '');
        
        if (result && result.length > 0) {
          this.logger.log(`‚úÖ DIAGN√ìSTICO - ¬°ENCONTRADO con variaci√≥n "${variacion}"!`);
          this.logger.log(`‚úÖ DIAGN√ìSTICO - Cliente: ${JSON.stringify(result[0], null, 2)}`);
          return { encontrado: true, variacion, cliente: result[0] };
        }
      }
      
      // Si no se encontr√≥, hacer una b√∫squeda m√°s amplia
      this.logger.log(`üîç DIAGN√ìSTICO - No encontrado con variaciones, buscando todos los tel√©fonos...`);
      const queryAmplia = `
        SELECT c.codigocliente, c.nombre, c.telefono1, c.telefono2, c.rif
        FROM clientes c
        WHERE c.telefono1 LIKE '%${numeroNormalizado.slice(-8)}%' OR c.telefono2 LIKE '%${numeroNormalizado.slice(-8)}%'
        LIMIT 10
      `;
      
      const resultadosAmplio = await this.valeryDbService.ejecutarQuery(queryAmplia, [], '');
      this.logger.log(`üîç DIAGN√ìSTICO - B√∫squeda amplia encontr√≥ ${resultadosAmplio?.length || 0} resultados`);
      
      if (resultadosAmplio && resultadosAmplio.length > 0) {
        resultadosAmplio.forEach((cliente, index) => {
          this.logger.log(`üîç DIAGN√ìSTICO - Resultado ${index + 1}: ${cliente.nombre} - Tel1: "${cliente.telefono1}" - Tel2: "${cliente.telefono2}"`);
        });
      }
      
      return { encontrado: false, variaciones, resultadosAmplio };
      
    } catch (error) {
      this.logger.error(`‚ùå Error en diagn√≥stico: ${error.message}`);
      return { error: error.message };
    }
  }

  /**
   * Generar mensaje de bienvenida para clientes nuevos
   */
  private async generateNewClientWelcome(session: PersistentSession): Promise<string> {
    const currentHour = new Date().getHours();
    const timeGreeting = this.getTimeBasedGreeting(currentHour);
    
    return `üéä ${timeGreeting}! üéä\n` +
           `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
           `üåü **¬°BIENVENIDO A G√ìMEZMARKET!** üåü\n` +
           `ü§ñ Soy **G√≥mezBot**, su asistente personal\n\n` +
           `üéØ **PARA COMENZAR** üéØ\n` +
           `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
           `üìù Ind√≠queme su **c√©dula o RIF**\n` +
           `‚ú® Le ofrecer√© un servicio personalizado\n` +
           `üöÄ ¬°Descubra nuestras ofertas exclusivas!\n\n` +
           `üìå **Ejemplo:** V12345678 o J408079305\n` +
           `üíé ¬°Su experiencia premium comienza aqu√≠! üíé`;
  }

  /**
   * Obtener configuracion del chatbot
   */
  private async getChatbotConfig(chatbotId: string): Promise<any> {
    try {
      const axios = require('axios');
      const response = await axios.get('http://localhost:3000/api/admin/multi-tenant/chatbots/' + chatbotId);
      return response.data.data;
    } catch (error) {
      this.logger.error('Error obteniendo configuracion del chatbot: ' + error.message);
      return null;
    }
  }

  // ==========================================
  // üÜï FUNCIONALIDADES AVANZADAS (similar a n8n)
  // ==========================================

  /**
   * HERRAMIENTA: run_query (equivalente a n8n)
   * Ejecuta consultas SQL inteligentes en la BD externa
   */
  async runQueryTool(queryType: string, searchTerm: string, marca?: string, session?: PersistentSession): Promise<any> {
    try {
      this.logger.log(`üîç [TOOL] run_query: ${queryType} para "${searchTerm}"`);
      
      // Obtener configuraci√≥n de BD externa
      const dbConfig = await this.getExternalDbConfig(session?.activeChatbotId);
      if (!dbConfig) {
        throw new Error('Configuraci√≥n de BD externa no disponible');
      }

      // Ejecutar consulta usando ValeryToolsService
      const result = await this.valeryToolsService.runQuery(
        queryType,
        searchTerm,
        marca,
        dbConfig
      );

      this.logger.log(`‚úÖ [TOOL] run_query ejecutada: ${result.rowCount || 0} resultados`);
      return result;

    } catch (error) {
      this.logger.error(`‚ùå [TOOL] Error en run_query: ${error.message}`);
      return {
        respuesta: `üòî No pude procesar la consulta en este momento: ${error.message}`,
        error: true
      };
    }
  }

  /**
   * HERRAMIENTA: crear_cliente (equivalente a n8n)
   * Crea nuevos clientes en la BD externa
   */
  async crearClienteTool(clienteData: any, session: PersistentSession): Promise<any> {
    try {
      this.logger.log(`üë§ [TOOL] crear_cliente: ${clienteData.nombre}`);
      
      const dbConfig = await this.getExternalDbConfig(session.activeChatbotId);
      if (!dbConfig) {
        throw new Error('Configuraci√≥n de BD externa no disponible');
      }

      const result = await this.valeryToolsService.crearCliente(clienteData, dbConfig);
      
      this.logger.log(`‚úÖ [TOOL] crear_cliente: ${result.cliente_existia ? 'Cliente existente' : 'Cliente nuevo'}`);
      return result;

    } catch (error) {
      this.logger.error(`‚ùå [TOOL] Error en crear_cliente: ${error.message}`);
      return {
        mensaje: `Error creando cliente: ${error.message}`,
        error: true
      };
    }
  }

  /**
   * HERRAMIENTA: crear_pedido (equivalente a n8n)
   * Crea pedidos completos en la BD externa
   */
  async crearPedidoTool(pedidoData: any, session: PersistentSession): Promise<any> {
    try {
      this.logger.log(`üìã [TOOL] crear_pedido para: ${pedidoData.pedido.nombrecliente}`);
      
      const dbConfig = await this.getExternalDbConfig(session.activeChatbotId);
      if (!dbConfig) {
        throw new Error('Configuraci√≥n de BD externa no disponible');
      }

      const result = await this.valeryToolsService.crearPedido(pedidoData, dbConfig);
      
      this.logger.log(`‚úÖ [TOOL] crear_pedido: ID ${result.id_pedido_creado}`);
      return result;

    } catch (error) {
      this.logger.error(`‚ùå [TOOL] Error en crear_pedido: ${error.message}`);
      return {
        confirmacion: `‚ùå Error creando pedido: ${error.message}`,
        error: true
      };
    }
  }

  /**
   * HERRAMIENTA: validar_pago (equivalente a n8n)
   * Valida pagos reportados por clientes
   */
  async validarPagoTool(pagoData: any, session: PersistentSession): Promise<any> {
    try {
      this.logger.log(`üí≥ [TOOL] validar_pago: ${pagoData.metodo} - $${pagoData.monto_reportado_cliente}`);
      
      // L√≥gica de validaci√≥n b√°sica implementada directamente
      const montoReportado = parseFloat(pagoData.monto_reportado_cliente);
      const montoEsperado = pagoData.metodo === 'zelle' ? pagoData.monto_esperado_usd : pagoData.monto_esperado_bs;
      const tolerancia = montoEsperado * 0.05; // 5% de tolerancia

      const montoValido = Math.abs(montoReportado - montoEsperado) <= tolerancia;

      const result = {
        pago_exitoso: montoValido,
        mensaje: montoValido 
          ? '‚úÖ Pago validado correctamente' 
          : `‚ùå Monto no coincide. Esperado: ${montoEsperado}, Recibido: ${montoReportado}`,
        monto_validado: montoReportado,
        monto_esperado: montoEsperado
      };

      this.logger.log(`‚úÖ [TOOL] validar_pago: ${montoValido ? 'V√ÅLIDO' : 'INV√ÅLIDO'}`);
      return result;

    } catch (error) {
      this.logger.error(`‚ùå [TOOL] Error en validar_pago: ${error.message}`);
      return {
        pago_exitoso: false,
        mensaje: `Error validando pago: ${error.message}`,
        error: true
      };
    }
  }

  /**
   * HERRAMIENTA: leer_ofertas (equivalente a n8n)
   * Lee ofertas especiales disponibles
   */
  async leerOfertasTool(codigocliente?: string): Promise<any> {
    try {
      this.logger.log(`üéâ [TOOL] leer_ofertas para cliente: ${codigocliente || 'general'}`);
      
      // Ofertas din√°micas basadas en la hora y d√≠a
      const ahora = new Date();
      const hora = ahora.getHours();
      const diaSemana = ahora.getDay();
      
      const ofertas = [];

      // Ofertas por horario
      if (hora >= 9 && hora <= 11) {
        ofertas.push('üåÖ ¬°Oferta Ma√±anera! 15% descuento en productos de desayuno');
      }
      
      if (hora >= 17 && hora <= 19) {
        ofertas.push('üåÜ ¬°Happy Hour! 10% descuento en bebidas y snacks');
      }

      // Ofertas por d√≠a de la semana
      if (diaSemana === 1) { // Lunes
        ofertas.push('üí™ ¬°Lunes Motivador! Env√≠o gratis en pedidos +$30');
      }
      
      if (diaSemana === 5) { // Viernes
        ofertas.push('üéâ ¬°Viernes de Ofertas! 2x1 en productos seleccionados');
      }

      // Ofertas est√°ticas
      ofertas.push('üõí Compra 3 productos y ll√©vate el 4to gratis');
      ofertas.push('üí∞ Env√≠o gratis en compras mayores a $50');

      const result = {
        ofertas: ofertas,
        mensaje: ofertas.length > 0 ? ofertas.join('\n\n') : 'No hay ofertas disponibles en este momento'
      };

      this.logger.log(`‚úÖ [TOOL] leer_ofertas: ${ofertas.length} ofertas disponibles`);
      return result;

    } catch (error) {
      this.logger.error(`‚ùå [TOOL] Error en leer_ofertas: ${error.message}`);
      return {
        ofertas: [],
        mensaje: 'No hay ofertas disponibles en este momento'
      };
    }
  }

  /**
   * HERRAMIENTA: get_schema (equivalente a n8n)
   * Obtiene esquema de BD para consultas din√°micas
   */
  async getSchemaTool(session: PersistentSession): Promise<any> {
    try {
      this.logger.log(`üìä [TOOL] get_schema para BD externa`);
      
      // Esquema b√°sico de las tablas principales
      const schema = {
        tablas: {
          inventario: {
            descripcion: 'Productos disponibles',
            campos: ['codigo', 'nombre', 'preciounidad', 'existenciaunidad', 'alicuotaiva', 'status']
          },
          clientes: {
            descripcion: 'Informaci√≥n de clientes',
            campos: ['codigocliente', 'nombre', 'rif', 'telefono1', 'direccion1', 'status']
          },
          encabedoc: {
            descripcion: 'Encabezados de pedidos',
            campos: ['idencabedoc', 'codcliente', 'nombrecliente', 'total', 'fechaemision', 'status']
          },
          movimientosdoc: {
            descripcion: 'Detalles de productos en pedidos',
            campos: ['idmovimientosdoc', 'idencabedoc', 'codigo', 'nombre', 'cantidad', 'precio']
          },
          pagos: {
            descripcion: 'Informaci√≥n de pagos',
            campos: ['idencabedoc', 'idtipo', 'monto', 'referencia', 'status']
          }
        },
        consultas_disponibles: [
          'consulta_inventario_termino_simple',
          'consulta_inventario_palabras_multiples',
          'buscar_cliente_por_telefono',
          'buscar_cliente_por_cedula'
        ]
      };

      this.logger.log(`‚úÖ [TOOL] get_schema: ${Object.keys(schema.tablas).length} tablas disponibles`);
      return schema;

    } catch (error) {
      this.logger.error(`‚ùå [TOOL] Error en get_schema: ${error.message}`);
      return {
        error: `Error obteniendo esquema: ${error.message}`
      };
    }
  }

  /**
   * Obtener configuraci√≥n de BD externa del chatbot
   * Prioriza la configuraci√≥n del frontend sobre las variables de entorno
   */
  private async getExternalDbConfig(chatbotId: string): Promise<any> {
    try {
      this.logger.log(`üîç Obteniendo configuraci√≥n de BD externa para chatbot: ${chatbotId}`);
      
      const chatbotConfig = await this.getChatbotConfig(chatbotId);
      if (chatbotConfig?.externalDbConfig?.enabled) {
        this.logger.log(`‚úÖ Usando configuraci√≥n de BD desde frontend para chatbot: ${chatbotId}`);
        return {
          host: chatbotConfig.externalDbConfig.host,
          port: chatbotConfig.externalDbConfig.port,
          database: chatbotConfig.externalDbConfig.database,
          username: chatbotConfig.externalDbConfig.username,
          password: chatbotConfig.externalDbConfig.password,
          ssl: chatbotConfig.externalDbConfig.ssl || false
        };
      }
      
      this.logger.warn(`‚ö†Ô∏è No hay configuraci√≥n de BD externa habilitada para chatbot: ${chatbotId}`);
      return null;
      
    } catch (error) {
      this.logger.error(`‚ùå Error obteniendo configuraci√≥n de BD externa: ${error.message}`);
      return null;
    }
  }

  /**
   * Procesamiento inteligente con herramientas (estilo n8n)
   */
  async processWithAdvancedTools(message: string, session: PersistentSession): Promise<string> {
    try {
      this.logger.log(`üß† [AI+TOOLS] Procesando mensaje con herramientas avanzadas: "${message}"`);
      
      // Detectar intent del mensaje
      const intent = await this.analyzeMessageIntent(message, session);
      
      switch (intent.type) {
        case 'product_search':
          // Usar herramienta run_query
          const searchResult = await this.runQueryTool(
            'consulta_inventario_termino_simple',
            intent.entities.product,
            intent.entities.brand,
            session
          );
          return searchResult.respuesta;

        case 'client_registration':
          // Usar herramienta crear_cliente
          const clientData = {
            codigocliente_propuesto: intent.entities.identification,
            rif: intent.entities.identification,
            nombre: intent.entities.name || 'Cliente WhatsApp',
            telefono1: session.phoneNumber,
            direccion1: intent.entities.address
          };
          const clientResult = await this.crearClienteTool(clientData, session);
          return clientResult.mensaje;

        case 'order_creation':
          // Usar herramienta crear_pedido
          const orderData = this.buildOrderFromCart(session);
          const orderResult = await this.crearPedidoTool(orderData, session);
          return orderResult.confirmacion;

        case 'payment_validation':
          // Usar herramienta validar_pago
          const paymentData = {
            metodo: intent.entities.payment_method,
            monto_reportado_cliente: intent.entities.amount,
            monto_esperado_usd: session.metadata?.total_usd || 0,
            monto_esperado_bs: session.metadata?.total_bs || 0,
            referencia_reportada_cliente: intent.entities.reference,
            telefono_cliente: session.phoneNumber,
            id_pedido: session.metadata?.order_id
          };
          const paymentResult = await this.validarPagoTool(paymentData, session);
          return paymentResult.mensaje;

        case 'offers_request':
          // Usar herramienta leer_ofertas
          const offersResult = await this.leerOfertasTool(session.metadata?.client_code);
          return offersResult.mensaje;

        default:
          // Proceso normal si no hay herramientas espec√≠ficas
          return await this.processIntelligentMessage(message, session, session.activeChatbotId);
      }

    } catch (error) {
      this.logger.error(`‚ùå [AI+TOOLS] Error en procesamiento avanzado: ${error.message}`);
      return 'üòî Disculpa, hubo un problema procesando tu solicitud. ¬øPodr√≠as intentar de nuevo?';
    }
  }

  /**
   * Construir datos de pedido desde el carrito
   */
  private buildOrderFromCart(session: PersistentSession): any {
    const cart = session.metadata?.cart || [];
    const cliente = session.metadata?.client || {};
    
    const subtotal = cart.reduce((sum, item) => sum + (item.precio * item.cantidad), 0);
    const iva = subtotal * 0.16;
    const total = subtotal + iva;

    return {
      query: {
        pedido: {
          codigocliente: cliente.codigo || session.phoneNumber,
          rif: cliente.rif || session.phoneNumber,
          nombrecliente: cliente.nombre || 'Cliente WhatsApp',
          telefonos: session.phoneNumber,
          monedacodigo: '02',
          moneda: 'DOLARES',
          tasa: 37.5,
          subtotal: subtotal,
          iva: iva,
          total: total,
          fechaemision: new Date().toISOString().split('T')[0],
          hora: new Date().toTimeString().split(' ')[0],
          observaciones: 'Pedido v√≠a WhatsApp',
          idpago: '02'
        },
        productos: cart.map(item => ({
          codigo: item.codigo,
          nombre: item.nombre,
          cantidad: item.cantidad,
          precio: item.precio,
          iva: item.precio * 0.16,
          preciototal: item.precio * item.cantidad * 1.16
        }))
      }
    };
  }

  private analyzeCartAction(message: string): { action: string, data?: any } {
    // Normalizar mensaje (min√∫sculas, sin acentos)
    const normalizedMessage = message.toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    
    // üîç PATRONES MEJORADOS PARA DETECTAR ACCIONES DE CARRITO
    
    // Patrones para AGREGAR al carrito
    if (
      /agregar\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage) ||   // "agregar producto 1"
      /agrega\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage) ||    // "agrega el 1"
      /agregar\s+\d+\s+(?:del|de|productos?|unidades?)/i.test(normalizedMessage) || // "agregar 2 del producto 3"
      /anadir\s+(?:al\s+)?carrito/i.test(normalizedMessage) ||               // "a√±adir al carrito"
      /poner\s+(?:en\s+)?(?:el\s+)?carrito/i.test(normalizedMessage) ||      // "poner en el carrito"
      /comprar\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage)     // "comprar el producto 1"
    ) {
      return { action: 'add' };
    }
    
    // Patrones para VER el carrito
    if (
      /ver\s+(?:mi\s+)?carrito/i.test(normalizedMessage) ||
      /mostrar\s+(?:mi\s+)?carrito/i.test(normalizedMessage) ||
      /(?:mi\s+)?carrito/i.test(normalizedMessage) ||
      /items\s+seleccionados/i.test(normalizedMessage) ||
      /productos\s+seleccionados/i.test(normalizedMessage) ||
      /que\s+llevo/i.test(normalizedMessage)
    ) {
      return { action: 'view' };
    }
    
    // Patrones para QUITAR productos del carrito
    if (
      /quitar\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage) ||
      /eliminar\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage) ||
      /remover\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage) ||
      /sacar\s+(?:el\s+)?(?:producto\s+)?\d+/i.test(normalizedMessage)
    ) {
      return { action: 'remove' };
    }
    
    // Patrones para VACIAR el carrito
    if (
      /vaciar\s+(?:el\s+)?carrito/i.test(normalizedMessage) ||
      /limpiar\s+(?:el\s+)?carrito/i.test(normalizedMessage) ||
      /eliminar\s+(?:todos\s+)?(?:los\s+)?productos/i.test(normalizedMessage) ||
      /quitar\s+todo/i.test(normalizedMessage)
    ) {
      return { action: 'clear' };
    }
    
    // Patrones para PROCEDER A COMPRAR
    if (
      /proceder\s+(?:a\s+)?(?:la\s+)?compra/i.test(normalizedMessage) ||
      /finalizar\s+(?:la\s+)?compra/i.test(normalizedMessage) ||
      /comprar\s+ahora/i.test(normalizedMessage) ||
      /checkout/i.test(normalizedMessage) ||
      /pagar/i.test(normalizedMessage)
    ) {
      return { action: 'checkout' };
    }
    
    // Si no se reconoce ninguna acci√≥n espec√≠fica
    return { action: 'unknown' };
  }
}
